(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _mjsMasonry = _interopRequireDefault(require("../mjs-masonry/mjs-masonry.js"));
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
    var dynamicLayout = {
      init: function init() {
        dynamicLayout.initShowMore();
        dynamicLayout.initMasonry();
      },
      initMasonry: function initMasonry() {
        // fail fast - masonry inside split frame not supported
        if (document.querySelector('[class$="--major"]')) {
          return;
        }
        var masonryGrids = document.querySelectorAll('.lumen-dynamic-layout--masonry .lumen-dynamic-layout__items');
        var mgi = masonryGrids.length;
        while (mgi--) {
          var elem = masonryGrids[mgi];
          _mjsMasonry["default"].init(elem);
        }
      },
      initShowMore: function initShowMore() {
        Array.prototype.forEach.call(document.querySelectorAll('.lumen-dynamic-layout__items'), function (list) {
          if (!list.querySelector('.lumen-dynamic-layout__show-more')) {
            return;
          }
          var max = list.dataset.show;
          var maxPlusOne = Math.floor(max) + 1;
          if (list.childElementCount > maxPlusOne) {
            list.classList.add('lumen-dynamic-layout__items--max-enabled');
            var lastShownItem = list.querySelector('.lumen-dynamic-layout__item:nth-child(' + max + ')');
            lastShownItem.classList.add('lumen-dynamic-layout__item--last-shown-item');
          }
          var showMore = list.querySelector('.lumen-dynamic-layout__show-more');
          showMore.addEventListener('click', function () {
            list.classList.remove('lumen-dynamic-layout__items--max-enabled');
            dynamicLayout.initMasonry();
          });
        });
      }
    };
    var _default = dynamicLayout;
    exports["default"] = _default;
    
    },{"../mjs-masonry/mjs-masonry.js":13}],2:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _mjsThrottle = _interopRequireDefault(require("../mjs-throttle/mjs-throttle.js"));
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
    var lumenImage = {
      init: function init() {
        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$customEvents = _ref.customEvents,
          customEvents = _ref$customEvents === void 0 ? [] : _ref$customEvents,
          _ref$padding = _ref.padding,
          padding = _ref$padding === void 0 ? 300 : _ref$padding,
          _ref$lazyClass = _ref.lazyClass,
          lazyClass = _ref$lazyClass === void 0 ? 'lumen-image__lazy' : _ref$lazyClass,
          _ref$loadedClass = _ref.loadedClass,
          loadedClass = _ref$loadedClass === void 0 ? 'lumen-image__loaded' : _ref$loadedClass,
          _ref$noJSClass = _ref.noJSClass,
          noJSClass = _ref$noJSClass === void 0 ? 'no-js' : _ref$noJSClass;
        // Setup object variables for reuse
        lumenImage.images = document.getElementsByClassName(lazyClass);
        lumenImage.padding = padding;
        lumenImage.noJSClass = noJSClass;
        lumenImage.events = ['scroll', 'hashchange', 'touchend', 'resize', 'click', 'orientationchange', 'keyup'].concat(customEvents);
        lumenImage.handleImagesThrottled = (0, _mjsThrottle["default"])(function () {
          return lumenImage.handleImages(lazyClass, loadedClass);
        }, 20);
        lumenImage.observer = new MutationObserver(function () {
          lumenImage.startLoader(lazyClass, loadedClass);
        });
    
        // Start lazy loading process
        lumenImage.startLoader(lazyClass, loadedClass);
      },
      // Starts (or restarts) the lazy loading process
      startLoader: function startLoader(lazyClass, loadedClass) {
        lumenImage.observer.disconnect();
        lumenImage.handleImages(lazyClass, loadedClass);
        lumenImage.addEvents();
      },
      // Adds the event listners to the page to trigger loading images
      addEvents: function addEvents() {
        lumenImage.events.forEach(function (ev) {
          window.addEventListener(ev, lumenImage.handleImagesThrottled);
        });
      },
      // Removes the event listners from the page
      removeEvents: function removeEvents() {
        lumenImage.events.forEach(function (ev) {
          window.removeEventListener(ev, lumenImage.handleImagesThrottled);
        });
      },
      // Controls what images get loaded
      handleImages: function handleImages(lazyClass, loadedClass) {
        // Turn off lazy loading if there are no more unloaded images
        if (lumenImage.images.length === 0) {
          // Set an observer to restart process if new elements are injected
          lumenImage.observer.observe(document.body, {
            childList: true,
            subtree: true
          });
          // Remove the events to halt the lazy loading process
          lumenImage.removeEvents();
          return;
        }
    
        // Loops through each picture element in the viewport
        [].filter.call(lumenImage.images, lumenImage.inRange).forEach(function (pic) {
          var img = pic.querySelector('img');
          // Check each source tag until a media query matches
          [].some.call(pic.querySelectorAll('source'), function (source) {
            // If the source media is currently true
            if (window.matchMedia(source.getAttribute('media')).matches) {
              // Check to see if the source has not already been loaded
              if (!source.classList.contains(loadedClass)) {
                // Set the srcset value
                lumenImage.changeAttributes({
                  'data-srcset': 'srcset'
                }).call(source);
                // Add a loaded class so that the srcset is not reset
                source.classList.add(loadedClass);
              }
    
              // return true so the loop ends and the other queries are not checked.
              return true;
            }
          });
    
          // Set the src for the fallback image - won't load if any of the source media queries are true
          // This is so lazy loading works for non art-directed images and IE
          lumenImage.changeAttributes({
            'data-src': 'src'
          }).call(img);
          !!img.dataset.srcset && lumenImage.changeAttributes({
            'data-srcset': 'srcset'
          }).call(img);
    
          // Update the state of the picture to loaded when all sources loaded
          var imageLoaded = function imageLoaded() {
            if (pic.querySelectorAll("source:not(.".concat(loadedClass, ")")).length === 0) {
              lumenImage.updateState(pic, lazyClass, loadedClass);
              img.removeEventListener('load', imageLoaded);
            }
          };
          img.addEventListener('load', imageLoaded);
        });
      },
      // Removes and adds a class to the element
      updateState: function updateState(el, removeClass, addClass) {
        el.classList.remove(removeClass);
        el.classList.add(addClass);
      },
      // Sets an attribute to the value of another attribute
      changeAttributes: function changeAttributes(attributeMap) {
        return function () {
          var _this = this;
          Object.keys(attributeMap).forEach(function (k) {
            return _this.setAttribute(attributeMap[k], _this.getAttribute(k));
          });
        };
      },
      // Detects if an image is in range of the viewport and visible
      inRange: function inRange(element) {
        var bounds = element.getBoundingClientRect();
        var padding = lumenImage.padding;
    
        // Remove the noJSClass so that the image can be visible since JS is working
        element.classList.remove(lumenImage.noJSClass);
        return element.offsetParent !== null && bounds.bottom >= 0 - padding && bounds.top <= window.innerHeight + padding && bounds.right >= 0 - padding && bounds.left <= window.innerWidth + padding;
      }
    };
    var _default = lumenImage;
    exports["default"] = _default;
    
    },{"../mjs-throttle/mjs-throttle.js":17}],3:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _mjsSocialHelper = _interopRequireDefault(require("../mjs-social-helper/mjs-social-helper.js"));
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
    var lumenQuote = {
      init: function init() {
        var socialButtons = [].slice.call(document.querySelectorAll('.lumen-quote__twitter'));
        socialButtons.forEach(function (button) {
          _mjsSocialHelper["default"].appendCurrentUrlToLink(button);
          button.addEventListener('click', _mjsSocialHelper["default"].openSocialShareWindow);
        });
      }
    };
    var _default = lumenQuote;
    exports["default"] = _default;
    
    },{"../mjs-social-helper/mjs-social-helper.js":15}],4:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _mjsSpillout = _interopRequireDefault(require("../../libs/mjs-spillout/mjs-spillout.js"));
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
    var lumenSubNav = {
      init: function init() {
        var subnavList = document.querySelector('.lumen-sub-nav__list');
        var advance = document.querySelector('.lumen-sub-nav__advance');
        var retreat = document.querySelector('.lumen-sub-nav__retreat');
        if (!subnavList) {
          return false;
        }
        var handleClick = function handleClick(e) {
          e.preventDefault();
          e.stopPropagation();
          var elem = e.currentTarget;
          var parent = elem.parentElement;
          var list = parent.querySelector('ul');
          var isOpen = list.classList.contains('active');
          var handleBodyClick = function handleBodyClick(e) {
            e.stopPropagation();
            removeActiveOpen();
            document.body.removeEventListener('click', handleBodyClick);
          };
          removeActiveOpen();
          if (!isOpen) {
            var posLeft = parent.getBoundingClientRect().left;
            list.style.right = 'auto';
            list.style.left = posLeft + 'px';
            parent.classList.add('open');
            list.classList.add('active');
            //collision detection with right
            //console.log(`${Math.ceil(posLeft)} + ${list.clientWidth} = ${Math.ceil(posLeft) + list.clientWidth}, ${document.body.clientWidth}`);
            if (Math.ceil(posLeft) + list.clientWidth >= document.body.clientWidth) {
              list.style.right = 0;
              list.style.left = 'auto';
            }
            document.body.addEventListener('click', handleBodyClick);
          }
        };
        var removeActiveOpen = function removeActiveOpen() {
          var opens = subnavList.querySelectorAll('li.open');
          var opensIndex = opens.length;
          while (opensIndex--) {
            var openList = opens[opensIndex];
            openList.classList.remove('open');
            openList.querySelector('ul').classList.remove('active');
          }
        };
        var secondaryLists = [].slice.call(subnavList.querySelectorAll('li span'));
        secondaryLists.forEach(function (subList) {
          subList.addEventListener('click', handleClick);
        });
    
        // spillout logic (probably mjs-make-fit) goes here
        subnavList.addEventListener('leftOverflowChange', function () {
          retreat.classList.toggle('active');
        });
        subnavList.addEventListener('rightOverflowChange', function () {
          advance.classList.toggle('active');
        });
        var container = subnavList; //spillout failed if not named container - not sure why
        (0, _mjsSpillout["default"])({
          container: container,
          advance: advance,
          retreat: retreat
        });
      }
    };
    var _default = lumenSubNav;
    exports["default"] = _default;
    
    },{"../../libs/mjs-spillout/mjs-spillout.js":16}],5:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _mjsMakeFit = _interopRequireDefault(require("../mjs-make-fit/mjs-make-fit.js"));
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
    var lumenTitleBlock = {
      init: function init() {
        var titleBlockOverlay = document.querySelector('.lumen-title-block--overlay');
    
        // Listen to mutations on lumen-video to adjust to whether or not the video is open.
        lumenTitleBlock.observer = new MutationObserver(function (mutations) {
          mutations.forEach(function (mutation) {
            lumenTitleBlock.removeTitleOverlayOnVideo(mutation.target);
          });
        });
        if (titleBlockOverlay) {
          var titleImg = titleBlockOverlay.querySelector('.lumen-media-block img');
          var video = titleBlockOverlay.querySelector('.lumen-video');
    
          // no image, huh? then no --overlay
          if (!titleImg) {
            titleBlockOverlay.classList.remove('lumen-title-block--overlay');
            return;
          }
          lumenTitleBlock.initMakeFit(titleBlockOverlay, titleImg);
          if (video) {
            video.titleBlock = titleBlockOverlay;
            lumenTitleBlock.observer.observe(video, {
              attributes: true,
              attributeFilter: ['class']
            });
          }
        }
      },
      initMakeFit: function initMakeFit(elem, titleImg) {
        var mf = _mjsMakeFit["default"].init({
          elemToFit: elem.querySelector('.lumen-title-block__heading-wrapper'),
          elemToTestFit: elem.querySelector('.lumen-title-block__title-wrapper'),
          elemsToAddClassTo: [elem],
          sizeClasses: ['lumen-title-block--fit-small', 'lumen-title-block--fit-smaller', 'lumen-title-block--fit-smallest'],
          fitType: ['height']
        });
        mf.run();
    
        //run makeFit again after image is loaded
        titleImg.onload = mf.run;
      },
      removeTitleOverlayOnVideo: function removeTitleOverlayOnVideo(video) {
        if (video.classList.contains('mediaLoader--open')) {
          var initialVideoRect = video.getBoundingClientRect();
          video.titleBlock.classList.add('lumen-title-block--overlay--play');
          // move the top of the video to where the top of title block used to be
          window.scrollBy(0, video.getBoundingClientRect().top - initialVideoRect.top);
        } else {
          var initialTitleBlockRect = video.titleBlock.getBoundingClientRect();
          video.titleBlock.classList.remove('lumen-title-block--overlay--play');
          // move the window to adjust for the shorter height of title block
          window.scrollBy(0, video.titleBlock.getBoundingClientRect().height - initialTitleBlockRect.height);
        }
      }
    };
    var _default = lumenTitleBlock;
    exports["default"] = _default;
    
    },{"../mjs-make-fit/mjs-make-fit.js":12}],6:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _mjsYoutubeCheck = _interopRequireDefault(require("../mjs-youtube-check/mjs-youtube-check.js"));
    var _mjsLoadScript = _interopRequireDefault(require("../mjs-load-script/mjs-load-script.js"));
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
    /* eslint-disable no-undef */
    
    var lumenVideo = {
      init: function init() {
        // fail fast
        if (!document.querySelector('.lumen-video')) {
          return;
        }
        _mjsYoutubeCheck["default"].check();
        if (typeof mediaLoader === 'undefined') {
          if (typeof cdnURL === 'undefined' || cdnURL === '//localhost:3000' || cdnURL === '//local.lds.org') {
            (0, _mjsLoadScript["default"])('https://edge.ldscdn.org/cdn2/common/media-loader/5.0.1/index.min.js', function () {
              lumenVideo.attachMediaLoader();
            });
          } else {
            (0, _mjsLoadScript["default"])(cdnURL + '/cdn2/common/media-loader/5.0.1/index.min.js', function () {
              lumenVideo.attachMediaLoader();
            });
          }
          window.LDS = {};
          LDS.setVideoPlayer = function (mediaID, player) {
            if (mediaID) {
              var curElem = document.getElementById(mediaID); // account for jquery based mediaLoader and new jqueryless mediaLoader
              var curID = mediaID;
              var mediaList = window['mlobj_' + curID];
              if (mediaList) {
                // console.debug('player', player);
                if (player === 'nbc') {
                  if (mediaList.params.videoID) {
                    mediaList.type = 'nbc';
                  } else {
                    console.warn('No videoID provided');
                  }
                } else if (player === 'yt') {
                  if (mediaList.youtubeid) {
                    mediaList.type = 'yt';
                  } else {
                    console.warn('No youtubeID provided');
                  }
                } else if (player === 'jw') {
                  if (mediaList.jwfile) {
                    mediaList.type = 'jw';
                  } else {
                    console.warn('No jwfile provided');
                  }
                } else if (player === 'bc') {
                  if (mediaList.params.playerID) {
                    mediaList.type = 'bc';
                  } else {
                    console.warn('No playerID provided');
                  }
                }
                curElem.mediaLoader('option', 'mediaList')[mediaID].type = player; // The mediaList inside of mediaLoader is an object that contains another object (with the name of our mediaID) that has the parameters we're looking for
                console.log(mediaID + ' will now be loaded using the ' + player + ' player.');
              } else {
                console.warn('No match found for: ' + mediaID);
              }
            } else {
              console.warn('No mediaID provided');
            }
          };
        } else {
          lumenVideo.attachMediaLoader();
        }
        lumenVideo.setupJumpPrevention();
        lumenVideo.deepLinker();
      },
      deepLinker: function deepLinker() {
        var vidDiv = document.querySelector('.lumen-video');
        var vidDivA = vidDiv.querySelector('a');
        var vidDivID = vidDiv.id;
        var openVideo = function openVideo() {
          vidDiv.mediaLoader("open", vidDivID);
        };
        // If the player hasn't initialized (if there's still an anchor in the .lumen-video element), run through the links whose hrefs start with #0 and make them open the video player
        if (vidDivA) {
          [].forEach.call(document.querySelectorAll('a[href^="#0"]'), function (e) {
            e.addEventListener('click', openVideo);
          });
        } else {
          e.removeEventListener('click', openVideo);
        }
      },
      attachMediaLoader: function attachMediaLoader() {
        var videos = document.querySelectorAll('.lumen-video');
        _mjsYoutubeCheck["default"].check().then(function (res) {
          var mediaData = {
            useHash: false,
            leaveOthersOpen: false,
            'youTubeCheck': res,
            mediaList: {}
          };
          for (var i = 0; i < videos.length; i++) {
            var elem = videos[i];
            var elemData = mediaData;
            var vidData = window['mlobj_' + elem.id];
            elemData.mediaList[elem.id] = {};
            if (vidData.type) {
              elemData.mediaList[elem.id].type = vidData.type;
            }
            if (vidData.fallback) {
              elemData.mediaList[elem.id].fallback = vidData.fallback;
            }
            if (vidData.youtubeid) {
              elemData.mediaList[elem.id].youtubeid = vidData.youtubeid;
            }
            if (vidData.jwfile) {
              elemData.mediaList[elem.id].jwfile = vidData.jwfile;
            }
            if (vidData.analyticsEnabled) {
              elemData.mediaList[elem.id].analytics = vidData.analyticsEnabled;
            }
            if (vidData.analyticsTitle) {
              elemData.mediaList[elem.id].title = vidData.analyticsTitle;
            }
            if (vidData.analyticsProduct) {
              elemData.mediaList[elem.id].product = vidData.analyticsProduct;
            }
            elemData.mediaList[elem.id].params = {};
            if (vidData.params.autoStart) {
              elemData.mediaList[elem.id].params.autoStart = vidData.params.autoStart;
            } else {
              elemData.mediaList[elem.id].params.autoStart = 'true';
            }
            if (vidData.params.videoID) {
              elemData.mediaList[elem.id].params.videoID = vidData.params.videoID;
            }
            if (vidData.params.playlistID) {
              elemData.mediaList[elem.id].params.playlistID = vidData.params.playlistID;
            }
            if (vidData.params.account) {
              elemData.mediaList[elem.id].params.account = vidData.params.account;
            }
            if (vidData.params.player) {
              elemData.mediaList[elem.id].params.player = vidData.params.player;
            }
            if (vidData.params['@videoPlayer']) {
              elemData.mediaList[elem.id].params['@videoPlayer'] = vidData.params['@videoPlayer'];
            }
            if (vidData.params.playerID) {
              elemData.mediaList[elem.id].params.playerID = vidData.params.playerID;
            }
            if (vidData.params.playerKey) {
              elemData.mediaList[elem.id].params.playerKey = vidData.params.playerKey;
            }
            window.mediaLoader('#' + elem.id, elemData);
          }
        });
      },
      // Prevent videos from jumping when the placeholder image is a different ratio from the video
      setupJumpPrevention: function setupJumpPrevention() {
        var observer = new MutationObserver(function () {
          // Makes sure that a click fired the mutation
          if (selectedVideo) {
            // Adjust the window so that the top of the clicked video remains in place
            window.scrollBy(0, selectedVideo.getBoundingClientRect().top - selectedVideoPosition);
    
            // Unset the positions so that any further mutations are ignored
            selectedVideo = undefined;
            selectedVideoPosition = undefined;
          }
        });
        var selectedVideo;
        var selectedVideoPosition;
    
        // Set the initial top position of the selected video
        var handleClick = function handleClick(e) {
          selectedVideo = e.currentTarget;
          selectedVideoPosition = selectedVideo.getBoundingClientRect().top;
        };
    
        // set up the events/observes for each video
        [].forEach.call(document.querySelectorAll('.lumen-video'), function (video) {
          video.addEventListener('click', handleClick);
          observer.observe(video, {
            attributes: true,
            attributeFilter: ['class']
          });
        });
      }
    };
    var _default = lumenVideo;
    exports["default"] = _default;
    
    },{"../mjs-load-script/mjs-load-script.js":11,"../mjs-youtube-check/mjs-youtube-check.js":18}],7:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var mjsAjax = function mjsAjax(options) {
      var empty = function empty() {};
      var onStatusChange = function onStatusChange() {
        if (request.readyState === 4) {
          var obj = {
            val: request.responseText,
            raw: request.responseText,
            status: request.status,
            statusText: request.statusText,
            caller: o.caller
          };
          if (o.container !== '') {
            obj.val = trimTo(request.responseText, o.container);
          }
          if (o.success && obj.status >= 200 && obj.status < 300) {
            o.success(obj);
          } else if (o.failure && (obj.status < 200 || obj.status >= 300)) {
            o.failure(obj);
          }
          if (o.complete) {
            o.complete(obj);
          }
        }
      };
      var trimTo = function trimTo(val, sel) {
        var v = val;
        if (sel) {
          try {
            // strip it down to the body
            v = v.match(/<body.*?>[\w\W]*<\/body>/)[0].replace(/<body.*?>/, '').replace(/<\/body>/, '');
            if (sel !== 'body') {
              // put it in an iframe so any executions won't bother the current document.
              var iframe = document.createElement('iframe');
              // need to append into the body in order for it to render it's dom. but we don't want to see it.
              iframe.style.display = 'none';
              document.body.appendChild(iframe);
              // get the doc for the iframe
              var idoc = iframe.document || iframe.contentDocument || iframe.contentWindow.document;
              // inject our newly acquired val into the iframe
              idoc.body.innerHTML = v;
              // find what you need now and give the innerhtml
              v = idoc.querySelector(sel).innerHTML;
              // and now remove the iframe
              iframe.parentElement.removeChild(iframe);
            }
          } catch (err) {}
        }
        return v;
      };
      var o = {
        url: options.url,
        //required
        type: options.type || 'GET',
        data: options.data || null,
        success: options.success || empty,
        failure: options.failure || empty,
        complete: options.complete || empty,
        container: options.container || '',
        caller: options.caller || '',
        sendingJson: options.sendingJson || false
      };
      var request = new XMLHttpRequest();
      request.onreadystatechange = onStatusChange;
      request.open(o.type, o.url, true);
      if (o.sendingJson) {
        request.setRequestHeader('Content-Type', 'application/json; charset=UTF-8');
        request.send(JSON.stringify(o.data));
      } else {
        request.send(o.data);
      }
    };
    var _default = mjsAjax;
    exports["default"] = _default;
    
    },{}],8:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = animate;
    exports.easingFunctions = void 0;
    var ease = {
      inCubic: function inCubic(t, b, c, d) {
        return c * (t /= d) * t * t + b;
      },
      outCubic: function outCubic(t, b, c, d) {
        return c * ((t = t / d - 1) * t * t + 1) + b;
      },
      inOutCubic: function inOutCubic(t, b, c, d) {
        if ((t /= d / 2) < 1) {
          return c / 2 * t * t * t + b;
        } else {
          return c / 2 * ((t -= 2) * t * t + 2) + b;
        }
      }
    };
    var easingFunctions = {
      inCubic: ease.inCubic,
      outCubic: ease.outCubic,
      inOutCubic: ease.inOutCubic
    };
    exports.easingFunctions = easingFunctions;
    function animate() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$start = _ref.start,
        start = _ref$start === void 0 ? 0 : _ref$start,
        _ref$end = _ref.end,
        end = _ref$end === void 0 ? 1 : _ref$end,
        _ref$amount = _ref.amount,
        amount = _ref$amount === void 0 ? amount || end - start : _ref$amount,
        _ref$duration = _ref.duration,
        duration = _ref$duration === void 0 ? 1000 : _ref$duration,
        _ref$easing = _ref.easing,
        easing = _ref$easing === void 0 ? 'inOutCubic' : _ref$easing,
        callback = _ref.callback;
      var startTime = window.performance.now();
      var move = function move(time) {
        time = time - startTime;
        if (time < duration) {
          callback(ease[easing](time, start, amount, duration));
          window.requestAnimationFrame(move);
        } else {
          callback(ease[easing](duration, start, amount, duration));
        }
      };
      move(startTime);
    }
    
    },{}],9:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var mjsCookie = {
      set: function set(name, val, days) {
        if (typeof name !== 'string' || name.trim() === '') {
          throw new Error('set() expects a string value for name');
        }
        var expires = '';
        if (days) {
          var date = new Date();
          date.setTime(date.getTime() + days * 24 * 60 * 60 * 1000);
          expires = '; expires=' + date.toGMTString();
        }
        document.cookie = name + '=' + val + expires + '; path=/';
      },
      get: function get(name) {
        var nameEQ = name.trim() + '=';
        var val = '';
        var cookieArray = document.cookie.split(';');
        for (var i = 0, len = cookieArray.length; i < len; i++) {
          var c = cookieArray[i].trim();
          if (c.indexOf(nameEQ) === 0) {
            val = c.substring(nameEQ.length, c.length);
            //return immediately if found
            return encodeURIComponent(val);
          }
        }
        return encodeURIComponent(val);
      },
      remove: function remove(name) {
        this.set(name, '', -1);
      }
    };
    var _default = mjsCookie;
    exports["default"] = _default;
    
    },{}],10:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var mjsDebounce = function mjsDebounce(func, wait, immediate) {
      var timeout;
      return function () {
        var context = this;
        var args = arguments;
        var later = function later() {
          timeout = null;
          if (!immediate) {
            func.apply(context, args);
          }
        };
        if (immediate && !timeout) {
          func.apply(context, args);
        }
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    };
    var _default = mjsDebounce;
    exports["default"] = _default;
    
    },{}],11:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var sparkLoadScript = function sparkLoadScript(url, callback) {
      if (typeof url !== 'string' || url.trim() === '') {
        throw new Error('url should be a valid string');
      }
      var newScript = document.createElement('script');
      var firstScript = document.querySelector('script');
      newScript.async = true;
      newScript.src = url;
      newScript.onload = newScript.onreadystatechange = function () {
        var rs = this.readyState;
        if (rs && rs !== 'complete' && rs !== 'loaded') {
          return;
        }
        if (callback) {
          callback();
        }
      };
      firstScript.parentNode.insertBefore(newScript, firstScript);
    };
    var _default = sparkLoadScript;
    exports["default"] = _default;
    
    },{}],12:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var makeFit = {
      options: {},
      init: function init(options) {
        options = options || {};
        var mf = {};
        mf.options = {
          elemToFit: options.elemToFit,
          sizeClasses: options.sizeClasses || ['makeFit-small', 'makeFit-smaller', 'makeFit-smallest'],
          resize: options.resize || function () {
            window.addEventListener('resize', mf.run);
            window.addEventListener('orientationchange', mf.run);
          },
          fitType: options.fitType || ['height', 'width'],
          maxHeight: options.maxHeight || undefined
        };
        mf.options.elemToTestFit = options.elemToTestFit || mf.options.elemToFit.parentElement;
        mf.options.elemsToAddClassTo = options.elemsToAddClassTo || [mf.options.elemToTestFit];
    
        //we are creating small caller functions that reside with the returned object, creating a factory.
        mf.run = function () {
          makeFit.run({
            mf: mf
          });
        };
        mf.removeClasses = function () {
          makeFit.removeClasses({
            sizeClasses: mf.options.sizeClasses,
            elemsToAddClassTo: mf.options.elemsToAddClassTo
          });
        };
        mf.testNotFit = function () {
          return makeFit.testNotFit({
            elemToTestFit: mf.options.elemToTestFit,
            elemToFit: mf.options.elemToFit,
            fitType: mf.options.fitType,
            maxHeight: mf.options.maxHeight
          });
        };
        mf.addClass = function (i) {
          makeFit.addClass({
            index: i,
            sizeClasses: mf.options.sizeClasses,
            mf: mf,
            elemsToAddClassTo: mf.options.elemsToAddClassTo
          });
        };
        if (mf.options.resize) {
          mf.options.resize();
        }
        return mf;
      },
      // these classes are written to be generic,
      // so they accept an object rather than reference a config,
      // that is what the `mf.` functions are for in the init function.
      run: function run(obj) {
        obj.mf.removeClasses();
        obj.mf.addClass(0);
      },
      removeClasses: function removeClasses(obj) {
        obj.sizeClasses.forEach(function (c) {
          obj.elemsToAddClassTo.forEach(function (elem) {
            elem.classList.remove(c);
          });
        });
      },
      testNotFit: function testNotFit(obj) {
        var itemNoLongerFits = false;
        var elemToTestFit = obj.elemToTestFit;
        var elemToFit = obj.elemToFit;
        var i = obj.fitType.length;
    
        //if any of them are true, return that.
        if (typeof obj.fitType === 'function') {
          itemNoLongerFits = obj.fitType(elemToFit, elemToTestFit);
        } else {
          fitTypeLoop: while (i--) {
            fitTypeSwitch: switch (obj.fitType[i]) {
              // if a word is longer than the container
              case 'width':
                itemNoLongerFits = Math.floor(elemToFit.scrollWidth) > Math.floor(elemToFit.offsetWidth) + 1;
                break fitTypeSwitch;
    
              //if there is an explicit max height
              case 'maxHeight':
                if (typeof obj.maxHeight === 'undefined') {
                  console.error('If you have a type of maxHeight you need to specify a max height in the options.');
                }
                itemNoLongerFits = elemToFit.offsetHeight > obj.maxHeight;
                break fitTypeSwitch;
    
              // default is 'height': if the fit element is taller than the test element.
              case 'height':
                itemNoLongerFits = elemToFit.offsetHeight > elemToTestFit.offsetHeight;
                break fitTypeSwitch;
              default:
                break fitTypeSwitch;
            }
            if (itemNoLongerFits) {
              break fitTypeLoop;
            }
          }
        }
    
        // a true means that the item no longer fits
        return itemNoLongerFits;
      },
      addClass: function addClass(obj) {
        var sizeClass = obj.sizeClasses[obj.index];
        var elemIndex = obj.elemsToAddClassTo.length;
        if (obj.mf.testNotFit()) {
          obj.mf.removeClasses();
          while (elemIndex--) {
            obj.elemsToAddClassTo[elemIndex].classList.add(sizeClass);
          }
          if (obj.index + 1 < obj.sizeClasses.length) {
            obj.mf.addClass(obj.index + 1);
          }
        }
      }
    };
    var _default = makeFit;
    exports["default"] = _default;
    
    },{}],13:[function(require,module,exports){
    "use strict";
    
    var _mjsThrottle = _interopRequireDefault(require("../mjs-throttle/mjs-throttle.js"));
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
    var masonry = {
      init: function init(container) {
        if (!container || !container.childElementCount) return;
        var m = {};
        var onImagesLoaded = function onImagesLoaded() {
          m.run();
        };
        m.opts = {
          container: container
        };
        m.run = function () {
          return masonry.run(m.opts.container);
        };
        var imgs = [].slice.call(m.opts.container.querySelectorAll('img'));
        if (imgs.length > 0) {
          imgs.forEach(function (img) {
            img.addEventListener('load', onImagesLoaded);
          });
        }
        masonry.resize(m.run);
        m.run();
        return m;
      },
      resizeFunctions: [],
      resize: function resize(func) {
        masonry.resizeFunctions.push(func);
        if (!masonry.onResize) {
          masonry.onResize = (0, _mjsThrottle["default"])(function () {
            masonry.resizeFunctions.forEach(function (callback) {
              callback();
            });
          }, 10);
          window.addEventListener('resize', masonry.onResize);
          window.addEventListener('orientationchange', masonry.onResize);
        }
      },
      run: function run(container) {
        var opts = {
          container: container
        };
        var containerPosition = getComputedStyle(container)['position'];
        if (containerPosition === 'static' || container.style.position !== 'relative') {
          container.style.position = 'relative';
        }
        opts.items = masonry.getItems(opts.container);
        opts.columns = masonry.getColumns(opts.items.topRow);
        masonry.fill(opts);
      },
      getChildren: function getChildren(container) {
        var children = [].slice.call(container.children);
        return children.filter(function (elem) {
          if (elem.classList.contains('masonry__ignore') || getComputedStyle(elem)['display'] === 'none') {
            return false;
          }
          elem.style.position = '';
          return true;
        });
      },
      getItems: function getItems(container) {
        var items = {
          all: masonry.getChildren(container),
          topRow: []
        };
        items.all.forEach(function (elem) {
          if (elem.offsetTop === 0) {
            items.topRow.push(elem);
          }
        });
        return items;
      },
      getMargin: function getMargin(item) {
        return parseInt(getComputedStyle(item)['margin-bottom'], 10);
      },
      getColumns: function getColumns(items) {
        var arr = [];
        items.forEach(function (elem) {
          arr.push(elem.offsetLeft);
        });
        return {
          number: items.length,
          left: arr,
          marginBottom: masonry.getMargin(items[0])
        };
      },
      fill: function fill(opts) {
        var columns = [];
        var i = opts.columns.number;
        var smallestColumn = function smallestColumn() {
          var min;
          var smallestColumn;
          for (var _i = 0; _i < columns.length; _i++) {
            var h = columns[_i].height;
            if (typeof min === 'undefined' || h < min) {
              min = h;
              smallestColumn = _i;
            }
          }
          return smallestColumn;
        };
        var largestColumn = function largestColumn() {
          var min;
          var largestColumn;
          for (var _i2 = 0; _i2 < columns.length; _i2++) {
            var h = columns[_i2].height;
            if (typeof min === 'undefined' || h > min) {
              min = h;
              largestColumn = _i2;
            }
          }
          return largestColumn;
        };
        while (i--) {
          columns.push({
            height: 0
          });
        }
        opts.items.all.forEach(function (elem) {
          var elemPosition = getComputedStyle(elem)['position'];
          var coli = smallestColumn();
          if (elemPosition !== 'absolute' || elem.style.position !== 'absolute') {
            elem.style.position = 'absolute';
          }
          elem.style.left = opts.columns.left[coli] + 'px';
          elem.style.top = columns[coli].height + opts.columns.marginBottom + 'px';
          columns[coli].height += elem.clientHeight + opts.columns.marginBottom;
          opts.container.style.height = columns[largestColumn()].height + opts.columns.marginBottom + 'px';
        });
      }
    };
    module.exports = masonry;
    
    },{"../mjs-throttle/mjs-throttle.js":17}],14:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var queryString = function queryString(key) {
      if (typeof key !== 'string' || key.trim() === '') {
        throw new Error('key should be a valid string');
      }
      key = encodeURIComponent(key.trim());
      var qs = window.location.search.substring(1);
      var rule = qs.split('&');
      var obj = {
        val: '',
        arr: []
      };
      for (var i = 0, len = rule.length; i < len; i++) {
        var kvp = rule[i].split('=');
        if (kvp[0] === key) {
          var val = decodeURIComponent(kvp[1]);
          obj.val = val;
          obj.arr = val.split(',');
    
          //no need to loop over remaining values
          i = len;
        }
      }
      obj.val = preventScriptInjection(obj.val);
      for (var _i = 0; _i < obj.arr.length; _i++) {
        obj.arr[_i] = preventScriptInjection(obj.arr[_i]);
      }
      return obj;
    };
    
    //transform value in attempt to prevent script injection
    var preventScriptInjection = function preventScriptInjection(val) {
      return val.replace(/</g, '&lt;').replace(/>/g, '&gt;');
    };
    var _default = queryString;
    exports["default"] = _default;
    
    },{}],15:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var mjsSocialHelper = {
      socialWindowPopup: null,
      previousUrl: '',
      appendCurrentUrlToLink: function appendCurrentUrlToLink(a) {
        var lastCharacter = a.href.charAt(a.href.length - 1);
        //only append url, if there is an empty parameter to append to
        //e.g. Twitter "url=" and Facebook "u="
        if (lastCharacter === '=') {
          a.href += window.location.href;
        }
      },
      openSocialShareWindow: function openSocialShareWindow(e) {
        e.preventDefault();
        var FEATURES = 'width=500,height=500';
    
        //no popup exists, so create it
        if (mjsSocialHelper.socialWindowPopup === null || mjsSocialHelper.socialWindowPopup.closed) {
          mjsSocialHelper.socialWindowPopup = window.open(this.href, this.target, FEATURES);
        }
        //it's open, but the url is different
        else if (mjsSocialHelper.previousUrl !== this.href) {
          mjsSocialHelper.socialWindowPopup = window.open(this.href, this.target, FEATURES);
          mjsSocialHelper.socialWindowPopup.focus();
        }
        //it's already open to the correct url
        else {
          mjsSocialHelper.socialWindowPopup.focus();
        }
        mjsSocialHelper.previousUrl = this.href;
      }
    };
    var _default = mjsSocialHelper;
    exports["default"] = _default;
    
    },{}],16:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Spillout = void 0;
    exports["default"] = spillout;
    var _mjsDebounce = _interopRequireDefault(require("../mjs-debounce/mjs-debounce.js"));
    var _mjsThrottle = _interopRequireDefault(require("../mjs-throttle/mjs-throttle.js"));
    var _mjsAnimate = _interopRequireDefault(require("../mjs-animate/mjs-animate.js"));
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
    // DRY function for firing IE11 safe custom events
    var fireEvent = function fireEvent(elem, type, details) {
      var event = document.createEvent('Event');
      event.initEvent(type, true, true);
      event.details = details;
      elem.dispatchEvent(event);
    };
    
    // Fires events for the left and right sides of the container having scrollable content
    var checkOverflow = function checkOverflow(container, overflow) {
      //Fix for IE & Edge bug where scrollWidth and clientWidth are within 1px of each other (rounding issue?)
      function equalWithinOne(scrollWidth, clientWidth, scrollLeft) {
        return Math.abs(scrollWidth - clientWidth - scrollLeft) <= 1;
      }
    
      // If overflow status of the right side is different than the previous check
      if (!equalWithinOne(container.scrollWidth, container.clientWidth, container.scrollLeft) !== overflow.right) {
        // Set the overflow state to the new value
        overflow.right = !overflow.right;
        // Fire an event marking a change in the right overflow status
        fireEvent(container, 'rightOverflowChange', {
          overflowStatus: overflow.right
        });
      }
    
      // If overflow status of the left side is different than the previous check
      // > 1 for IE and Edge bug
      if (container.scrollLeft > 1 !== overflow.left) {
        // Set the overflow state to the new value
        overflow.left = !overflow.left;
        // Fire an event marking a change in the left overflow status
        fireEvent(container, 'leftOverflowChange', {
          overflowStatus: overflow.left
        });
      }
    };
    
    // Animates the scrollLeft property
    var animateScroll = function animateScroll(amount, duration, container) {
      var start = container.scrollLeft;
      // Lowest possible endpoint, maximum possible endpoint and calculated endpoint from given amount
      var endpoints = [0, container.scrollWidth - container.clientWidth, start + amount];
    
      // Function so that mjs-animate can set the property
      var setScrollLeft = function setScrollLeft(value) {
        container.scrollLeft = start + amount * value;
      };
    
      // The median value of the possible endpoints minus the start position will never land
      // outside the containers max or min scroll value
      amount = endpoints[1] + endpoints[2] - Math.min.apply(Math, endpoints) - Math.max.apply(Math, endpoints) - start;
      (0, _mjsAnimate["default"])({
        duration: duration,
        callback: setScrollLeft
      });
    };
    
    // Sets up the events for the container to be dragable
    var startDrag = function startDrag(e) {
      var prevPos = e.clientX;
      var container = e.currentTarget;
    
      // Prevents the scrollbar from scrolling the opposite direction when cursor goes outside the viewport
      container.style.overflowX = 'hidden';
    
      // Adjust the scroll position by the difference from the previous and current cursor position
      window.onmousemove = (0, _mjsThrottle["default"])(function (e) {
        container.scrollLeft -= e.clientX - prevPos;
        prevPos = e.clientX;
      }, 20);
    
      // Remove the listeners and allow default scrolling when the mouse is lifted
      window.onmouseup = function () {
        container.style.overflowX = null;
        window.onmousemove = null;
        window.onmouseup = null;
      };
    };
    
    // Factory function to build and return the spillout object
    var init = function init() {
      var spillout = {
        overflow: {
          left: false,
          right: false
        },
        overflowEvents: function overflowEvents(container) {
          checkOverflow(container, spillout.overflow);
        },
        animateScroll: animateScroll,
        setupDragEvents: function setupDragEvents(container) {
          // Set up any drag related mouse events on the container
          container.addEventListener('mousedown', startDrag);
        }
      };
      return spillout;
    };
    var Spillout = {
      init: init
    };
    
    // Default setup for spillout
    exports.Spillout = Spillout;
    function spillout(_ref) {
      var container = _ref.container,
        advance = _ref.advance,
        retreat = _ref.retreat,
        active = _ref.active,
        _ref$activeOffset = _ref.activeOffset,
        activeOffset = _ref$activeOffset === void 0 ? 0 : _ref$activeOffset,
        _ref$scrollDuration = _ref.scrollDuration,
        scrollDuration = _ref$scrollDuration === void 0 ? 1000 : _ref$scrollDuration,
        _ref$scrollAmount = _ref.scrollAmount,
        scrollAmount = _ref$scrollAmount === void 0 ? function () {
          return container.clientWidth;
        } : _ref$scrollAmount;
      // Get a spillout object
      var spillout = init();
    
      // Alert any listeners to the current overflow status of the container
      spillout.overflowEvents(container);
      // Listen for any changes in the oferflow status and alert any listeners
      container.addEventListener('scroll', (0, _mjsThrottle["default"])(function () {
        spillout.overflowEvents(container);
      }, 30));
      window.addEventListener('resize', (0, _mjsDebounce["default"])(function () {
        spillout.overflowEvents(container);
      }, 250));
      spillout.setupDragEvents(container);
    
      // Add animation to the advance button
      advance && advance.addEventListener('click', function () {
        spillout.animateScroll(scrollAmount(), scrollDuration, container);
      });
    
      // Add animation to the retreat button
      retreat && retreat.addEventListener('click', function () {
        spillout.animateScroll(scrollAmount() * -1, scrollDuration, container);
      });
    
      // Set the active item to leftmost position minus and offset
      if (active) {
        container.scrollLeft = active.offsetLeft - activeOffset;
      }
      return spillout;
    }
    
    },{"../mjs-animate/mjs-animate.js":8,"../mjs-debounce/mjs-debounce.js":10,"../mjs-throttle/mjs-throttle.js":17}],17:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var mjsThrottle = function mjsThrottle(func, wait) {
      var allow = true;
      var first = true;
      return function () {
        if (allow) {
          var args = arguments;
          var context = arguments[0] ? arguments[0].target : this;
          var setAllow = function setAllow() {
            allow = true;
            func.apply(context, args);
          };
          if (first) func.apply(context, args);
          first = allow = false;
          setTimeout(setAllow, wait);
        }
      };
    };
    var _default = mjsThrottle;
    exports["default"] = _default;
    
    },{}],18:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _mjsCookie = _interopRequireDefault(require("../mjs-cookie/mjs-cookie.js"));
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
    var mjsYoutubeCheck = {
      init: function init() {
        this.check();
      },
      check: function check() {
        return new Promise(function (resolve, reject) {
          var cookieName = 'mjs-youtube';
          var youtubeCookie = _mjsCookie["default"].get(cookieName);
    
          // if youtubeCookie is empty that means the cookie hasn't been set yet.
          if (youtubeCookie === '') {
            var oneHour = 1 / 24; //as fraction of 1 day
            //request something from youtube.com, not a cdn, that will tell us if YouTube is blocked.
            var youTubeImage = new Image();
            var timestamp = new Date().getTime();
            youTubeImage.src = "//www.youtube.com/favicon.ico?".concat(timestamp); // add timestamp to make sure we aren't getting a cached version
            youTubeImage.onload = function () {
              _mjsCookie["default"].set(cookieName, true, oneHour);
              resolve('true');
            };
            youTubeImage.onerror = function () {
              _mjsCookie["default"].set(cookieName, false, oneHour);
              resolve('false');
            };
    
            //check the cookie for any changes
            youtubeCookie = _mjsCookie["default"].get(cookieName);
          } else {
            resolve(youtubeCookie === 'true');
          }
        });
      }
    };
    var _default = mjsYoutubeCheck;
    exports["default"] = _default;
    
    },{"../mjs-cookie/mjs-cookie.js":9}],19:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _mjsAjax = _interopRequireDefault(require("../mjs-ajax/mjs-ajax.js"));
    var _mjsQueryString = _interopRequireDefault(require("../mjs-query-string/mjs-query-string.js"));
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
    var formAdmin = {
      path: '',
      init: function init() {
        if (document.querySelectorAll('.publisher-form-admin').length <= 0) {
          return;
        }
        var path = window.location.pathname;
        formAdmin.path = path.endsWith('/') ? path : path + '/';
    
        //show or hide links based on search query
        var links = document.querySelectorAll('.publisher-form-admin__component-item');
        var searchField = document.getElementById('search-field');
        var handleSearchChange = function handleSearchChange() {
          var query = searchField.value;
          [].forEach.call(links, function (link) {
            if (link.getAttribute('data-meta').toLowerCase().indexOf(query.toLowerCase()) === -1) {
              link.classList.add('hidden');
            } else {
              link.classList.remove('hidden');
            }
          });
        };
        var handleHeadingClick = function handleHeadingClick() {
          this.classList.toggle('active');
          this.parentElement.querySelector('.publisher-form-admin__metadata-section').classList.toggle('active');
        };
        var handleNameChange = function handleNameChange(elem) {
          var proj = window.location.host.toLowerCase().indexOf('local') >= 0 ? window.location.pathname.substring(0, window.location.pathname.indexOf('/admin')) : '';
          var viewPage = elem.parentElement.parentElement.querySelector('.view-page');
          var go = elem.parentElement.querySelector('a');
          var path = window.location.origin + proj + elem.value;
          go.dataset.uri = elem.value;
          viewPage.innerHTML = path;
          viewPage.href = path;
        };
        var handleUpdateAllClick = function handleUpdateAllClick(e) {
          var caller = e.currentTarget;
          var elems = [].slice.call(document.querySelectorAll('.publisher-form-admin__component-item.created.valid'));
          var complete_i = 0;
          var results = {
            success: [],
            fail: []
          };
          var handleAjaxSuccess = function handleAjaxSuccess(obj) {
            if (JSON.parse(obj.val).result.status === '-1') {
              results.fail.push({
                component: obj.caller.querySelector('h2').innerHTML,
                result: obj,
                status: 'Failed'
              });
            } else {
              results.success.push({
                component: obj.caller.querySelector('h2').innerHTML,
                result: obj,
                status: 'Succeded'
              });
            }
          };
          var handleAjaxFail = function handleAjaxFail(obj) {
            results.fail.push({
              component: obj.caller.querySelector('h2').innerHTML,
              result: obj,
              status: 'Failed'
            });
          };
          var handleAjaxComplete = function handleAjaxComplete() {
            complete_i++;
            if (complete_i === elems.length) {
              caller.classList.remove('ajaxn');
              var html = '<h2>Bulk Update Results:</h2>';
              var injectHTML = function injectHTML(label, arr) {
                html += "<h3>".concat(label, "</h3>");
                if (arr.length > 0) {
                  html += '<ul>';
                  arr.forEach(function (item) {
                    html += "<li>\n                                                    <p>".concat(item.component, "</p>\n                                                </li>");
                  });
                  html += '</ul>';
                } else {
                  html += "<div> There were no items in '".concat(label, "'</div>");
                }
              };
              injectHTML('Failed', results.fail);
              injectHTML('Success', results.success);
              html += "<p>\n                                        <small>* if you would like to see more details, open your console and look for the result object.</small>\n                                    </p>\n                                    <p>\n                                        <small>\u2020 To see your list of components, refresh the page.</small>\n                                    </p>";
              console.log(results);
              document.querySelector('.publisher-form-admin__item-container').innerHTML = html;
            }
          };
          caller.classList.add('ajaxn');
          elems.forEach(function (elem) {
            var button = elem.querySelector('.create-form-button');
            (0, _mjsAjax["default"])({
              type: 'POST',
              complete: handleAjaxComplete,
              success: handleAjaxSuccess,
              failure: handleAjaxFail,
              container: '',
              caller: elem,
              data: {
                path: button.dataset.path
              },
              url: formAdmin.path + 'create-form',
              sendingJson: true
            });
          });
        };
        var handleButtonClick = function handleButtonClick(e) {
          //we are going to hanlde all button clicks here, based on the data.
          var caller = e.currentTarget;
          caller.classList.add('ajaxn');
          var options = {
            type: 'POST',
            complete: handleAjaxComplete,
            container: '',
            caller: caller,
            sendingJson: true
          };
          var lookup = {
            'view-template': formAdmin.path + 'view-template',
            'view-data': formAdmin.path + 'view-data',
            'view-schema': formAdmin.path + 'get-schema',
            'view-aggregated-schema': formAdmin.path + 'get-aggregated-schema',
            'create-form': formAdmin.path + 'create-form',
            'create-content': formAdmin.path + 'check-for-content',
            'view-form': formAdmin.path + 'view-form',
            'delete-form': formAdmin.path + 'delete-form'
          };
    
          //Pull these from the object that is calling the event.
          options.url = lookup[caller.dataset.formname];
    
          //schema, form-name, uri, path
          if (caller.dataset.schema && caller.dataset.schema !== '') {
            options.data = {
              schema: caller.dataset.schema
            };
          } else if (caller.dataset.form && caller.dataset.form !== '') {
            options.data = {
              'form-name': caller.dataset.form
            };
          } else if (caller.dataset.path && caller.dataset.path !== '') {
            options.data = {
              path: caller.dataset.path
            };
          } else if (caller.dataset.uri && caller.dataset.uri !== '') {
            options.data = {
              uri: caller.dataset.uri
            };
          }
          (0, _mjsAjax["default"])(options);
        };
        var handleAjaxComplete = function handleAjaxComplete(obj) {
          obj.caller.classList.remove('ajaxn');
          var elem = obj.caller;
          var s = '';
          var o = JSON.parse(obj.val.replace(/</gi, '&lt;').replace(/>/gi, '&gt;').replace(/\\n/gi, '<br>').replace(/\\t/gi, '&nbsp;&nbsp;&nbsp;&nbsp;'));
          while (!elem.classList.contains('publisher-form-admin__component-item')) {
            elem = elem.parentElement;
          }
          if (o.responseText) {
            s += o.responseText.replace(/\\"/gi, '"') + '<br>';
          }
          if (o.result) {
            if (o.result.message) {
              s += o.result.message.replace(/\\"/gi, '"') + '<br>';
            }
            if (o.result.content) {
              s += o.result.content.replace(/\\"/gi, '"') + '<br>';
            }
            if (o.result.location) {
              s += o.result.location.replace(/\\"/gi, '"') + '<br>';
            }
            if (o.result.form) {
              s += o.result.form.replace(/\\"/gi, '"') + '<br>';
            }
          }
          var codeContainer = elem.querySelector('.publisher-form-admin__code-container');
          codeContainer.innerHTML = '<pre><code>' + s + '</pre></code>';
          if (o.result.foundContent) {
            window.open(obj.caller.dataset.createurl + obj.caller.dataset.uri);
          }
    
          //if you created a schema, or deleted one, let's reload the page and isolate the component that you just generated or deleted.
          if (obj.caller.dataset.formname === 'create-form' || obj.caller.dataset.formname === 'delete-form') {
            window.setTimeout(function () {
              window.location = formAdmin.path + '?q=' + elem.querySelector('h2').innerHTML;
            }, 1000);
          }
        };
        var pathFields = document.querySelectorAll('.content-path');
        var path_i = pathFields.length;
        var handlePathChange = function handlePathChange() {
          handleNameChange(this);
        };
        var buttons = document.querySelectorAll('[data-formname]');
        var buttons_i = buttons.length;
        var headings = document.querySelectorAll('.publisher-form-admin__component-item > h2');
        var headings_i = headings.length;
        var updateAllButtons = document.querySelectorAll('.publisher-form-admin__update-all');
        var allButtons_i = updateAllButtons.length;
        searchField.addEventListener('keyup', handleSearchChange);
    
        //if there is a querystring, then let's load that into the searchField and rund handleSearchChange so that a page reload will display the right data-meta
        searchField.value = (0, _mjsQueryString["default"])('q').val;
        handleSearchChange();
        while (path_i--) {
          handleNameChange(pathFields[path_i]);
          pathFields[path_i].addEventListener('keyup', handlePathChange);
        }
        while (buttons_i--) {
          buttons[buttons_i].addEventListener('click', handleButtonClick);
        }
        while (headings_i--) {
          headings[headings_i].addEventListener('click', handleHeadingClick);
        }
        while (allButtons_i--) {
          updateAllButtons[allButtons_i].addEventListener('click', handleUpdateAllClick);
        }
      }
    };
    var _default = formAdmin;
    exports["default"] = _default;
    
    },{"../mjs-ajax/mjs-ajax.js":7,"../mjs-query-string/mjs-query-string.js":14}],20:[function(require,module,exports){
    "use strict";
    
    var _mjsSocialHelper = _interopRequireDefault(require("../mjs-social-helper/mjs-social-helper.js"));
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
    var sparkContentActions = {
      init: function init() {
        var contentActions = [].slice.call(document.querySelectorAll('.spark-content-actions'));
        contentActions.forEach(function (context) {
          sparkContentActions.initActions(context);
          sparkContentActions.initSocialButtons(context);
        });
      },
      initActions: function initActions(context) {
        var actionItems = [].slice.call(context.querySelectorAll('[data-content-action]'));
        actionItems.forEach(function (elem) {
          var action = sparkContentActions.actions[elem.dataset.contentAction];
          elem.addEventListener('click', action);
        });
      },
      initSocialButtons: function initSocialButtons(context) {
        var socialButtons = [].slice.call(context.querySelectorAll('.spark-content-actions__twitter, .spark-content-actions__facebook, .spark-content-actions__ok, .spark-content-actions__vk, .spark-content-actions__google-plus, .spark-content-actions__whatsapp'));
        socialButtons.forEach(function (button) {
          _mjsSocialHelper["default"].appendCurrentUrlToLink(button);
          button.addEventListener('click', _mjsSocialHelper["default"].openSocialShareWindow);
        });
      },
      actions: {
        print: function print() {
          window.print();
        }
      }
    };
    module.exports = sparkContentActions;
    
    },{"../mjs-social-helper/mjs-social-helper.js":15}],21:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var sparkDrawer = {
      drawerTriggerClass: 'spark-drawer__title',
      drawerContainerClass: 'spark-drawer__container',
      collapseAll: function collapseAll(element, sisterElement) {
        var expandedTriggerClass = ".".concat(sparkDrawer.drawerTriggerClass, "[aria-expanded=true]");
        var triggers = element.parentElement.querySelectorAll(expandedTriggerClass);
        var containers = sisterElement.parentElement.querySelectorAll(".".concat(sparkDrawer.drawerContainerClass, ".active"));
        Array.from(triggers, function (el) {
          return el.setAttribute('aria-expanded', 'false');
        });
        Array.from(containers, function (el) {
          return el.classList.remove('active');
        });
      },
      toggle: function toggle(element) {
        var state = element.getAttribute('aria-expanded');
        var sisterElement = document.getElementById(element.hash.slice(1));
        if (element.getAttribute('data-multi-expand') === 'false') {
          sparkDrawer.collapseAll(element, sisterElement);
        }
        element.setAttribute('aria-expanded', state === 'false' ? 'true' : 'false');
        if (sisterElement) {
          sisterElement.classList[state === 'false' ? 'add' : 'remove']('active');
        }
      },
      init: function init() {
        var drawers = Array.prototype.slice.call(document.querySelectorAll('.' + sparkDrawer.drawerTriggerClass));
        drawers.map(function (drawer) {
          drawer.addEventListener('click', function (e) {
            e.preventDefault();
            sparkDrawer.toggle(drawer);
          });
        });
      }
    };
    var _default = sparkDrawer;
    exports["default"] = _default;
    
    },{}],22:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _mjsMakeFit = _interopRequireDefault(require("../mjs-make-fit/mjs-make-fit.js"));
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
    var sparkFeature = {
      init: function init() {
        var features = document.querySelectorAll('.spark-feature:not(.spark-feature--text-right)');
        var i = features.length;
        var sizeClasses = ['spark-feature--fit-small', 'spark-feature--fit-smaller', 'spark-feature--fit-smallest'];
        while (i--) {
          var elem = features[i];
          var mf = _mjsMakeFit["default"].init({
            elemToFit: elem.querySelector('.spark-feature__text'),
            elemToTestFit: elem.querySelector('.spark-feature'),
            sizeClasses: sizeClasses,
            fitType: ['height']
          });
          elem.querySelector('.lumen-image img').onload = mf.run;
        }
        var rightFeatures = document.querySelectorAll('.spark-feature--text-right');
        var rightFeatures_i = rightFeatures.length;
        var rightFeaturesSizeClasses = ['spark-feature--text-right--fit-small', 'spark-feature--text-right--fit-smaller', 'spark-feature--text-right--fit-smallest'];
        while (rightFeatures_i--) {
          var _elem = rightFeatures[rightFeatures_i];
          var mf2 = _mjsMakeFit["default"].init({
            elemToFit: _elem.querySelector('.spark-feature__text'),
            elemToTestFit: _elem.querySelector('.lumen-image'),
            sizeClasses: rightFeaturesSizeClasses,
            elemsToAddClassTo: [_elem],
            fitType: ['height']
          });
          _elem.querySelector('.lumen-image img').onload = mf2.run;
        }
      }
    };
    var _default = sparkFeature;
    exports["default"] = _default;
    
    },{"../mjs-make-fit/mjs-make-fit.js":12}],23:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var scrollToElement = require('scroll-to-element');
    var Module = {
      init: function init() {
        [].forEach.call(document.querySelectorAll('.spark-image-gallery-item'), function (galleryItem, i, galleryItems) {
          var galleryImage = galleryItem.querySelector('.lumen-image');
          galleryImage.addEventListener('click', function () {
            Module.handleItemClick(galleryItem, galleryItems);
          });
        });
        [].forEach.call(document.querySelectorAll('.spark-image-gallery-item__drawer__close'), function (closeBtn) {
          closeBtn.addEventListener('click', function () {
            var closestGalleryItem = Module.closest(this, 'spark-image-gallery-item');
            Module.closeItem(closestGalleryItem);
          });
        });
        [].forEach.call(document.querySelectorAll('.spark-image-gallery-item__drawer__download'), function (downloadBtn) {
          downloadBtn.addEventListener('click', function () {
            Module.toggleDownloadsActive(this, false);
          });
        });
    
        // Clicking close button or button to start image download will remove the downloads active content
        [].forEach.call(document.querySelectorAll('.spark-image-gallery-item__downloads__close, .spark-image-gallery-item__downloads__buttons .lumen-button'), function (button) {
          button.addEventListener('click', function () {
            Module.toggleDownloadsActive(this, true);
          });
        });
      },
      handleItemClick: function handleItemClick(itemClicked, galleryItems) {
        var selectedItem = Module.toggleItemSelected(itemClicked, galleryItems);
        Module.displayDrawer(selectedItem);
      },
      displayDrawer: function displayDrawer(selectedItem) {
        var isScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        // fail fast
        if (!selectedItem) {
          return;
        }
        var itemPadding = 15;
        var container = selectedItem.parentElement;
        var drawer = selectedItem.querySelector('.spark-image-gallery-item__drawer');
        selectedItem.style.marginBottom = drawer.offsetHeight + itemPadding * 2 + 'px';
        drawer.style.left = container.offsetLeft - selectedItem.offsetLeft + 'px';
        drawer.style.top = selectedItem.offsetHeight + itemPadding - 1 + 'px';
    
        // if the drawer is not in view, scroll to top of image above it
        var drawerRect = drawer.getBoundingClientRect();
        if (isScroll && drawerRect.bottom - 40 > window.innerHeight) {
          scrollToElement(selectedItem, {
            offset: -20,
            ease: 'inOutQuad',
            duration: 500
          });
        }
      },
      toggleItemSelected: function toggleItemSelected(item, allItems) {
        var selectedItem = null;
        //reset 'selected' item
        if (item.classList.contains('selected')) {
          Module.closeItem(item);
        } else {
          //close all items
          [].forEach.call(allItems, function (item) {
            Module.closeItem(item);
          });
          item.classList.add('selected');
          selectedItem = item;
        }
        return selectedItem;
      },
      toggleDownloadsActive: function toggleDownloadsActive(clickedElement, isActive) {
        var closestDrawer = Module.closest(clickedElement, 'spark-image-gallery-item__drawer');
        if (isActive) {
          closestDrawer.classList.remove('spark-image-gallery-item__drawer--downloads-active');
        } else {
          closestDrawer.classList.add('spark-image-gallery-item__drawer--downloads-active');
        }
        Module.displayDrawer(Module.closest(clickedElement, 'spark-image-gallery-item'), false);
      },
      closeItem: function closeItem(item) {
        if (item === null) {
          return;
        }
        item.classList.remove('selected');
        item.style.marginBottom = '';
      },
      closest: function closest(currentElem, className) {
        while (currentElem !== document.body) {
          if (currentElem.classList.contains(className)) {
            return currentElem;
          }
          currentElem = currentElem.parentElement;
        }
        return null;
      }
    };
    var _default = Module;
    exports["default"] = _default;
    
    },{"scroll-to-element":37}],24:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _mjsDebounce = _interopRequireDefault(require("../mjs-debounce/mjs-debounce.js"));
    var _sparkImageGalleryItem = _interopRequireDefault(require("../spark-image-gallery-item/spark-image-gallery-item.js"));
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
    var justifiedLayout = require('justified-layout');
    var maxRows = 3;
    var sparkImageGallery = {
      init: function init() {
        [].forEach.call(document.querySelectorAll('.spark-image-gallery'), function (imgGallery) {
          var aspectRatiosData = imgGallery.dataset.aspectRatios;
          var aspectRatios = [];
          maxRows = parseInt(imgGallery.dataset.numOfRows, 10);
          if (aspectRatiosData) {
            aspectRatios = aspectRatiosData.split(',').map(function (ar) {
              return parseFloat(ar);
            });
            sparkImageGallery.initJustifiedLayout(imgGallery, aspectRatios, maxRows);
          } else {
            var images = imgGallery.querySelectorAll('.spark-image-gallery-item > .lumen-image .lumen-image__image');
            for (var i = 0, length = images.length; i < length; i++) {
              // eslint-disable-next-line no-loop-func
              images[i].onload = function () {
                aspectRatios = [];
                [].forEach.call(images, function (img) {
                  var aspectRatio = img.naturalWidth / img.naturalHeight;
                  if (isNaN(aspectRatio) || aspectRatio <= 0) {
                    aspectRatio = 1;
                  }
                  aspectRatios.push(aspectRatio);
                });
                sparkImageGallery.initJustifiedLayout(imgGallery, aspectRatios, maxRows);
              };
            }
          }
          var debouncedJustifiedLayout = (0, _mjsDebounce["default"])(function () {
            sparkImageGallery.initJustifiedLayout(imgGallery, aspectRatios, maxRows);
            var selectedItem = imgGallery.querySelector('.spark-image-gallery-item.selected');
            _sparkImageGalleryItem["default"].displayDrawer(selectedItem);
          }, 200);
          window.addEventListener('resize', debouncedJustifiedLayout);
          imgGallery.querySelector('.spark-image-gallery__load-more').addEventListener('click', function () {
            var numRowsToLoad = parseInt(imgGallery.dataset.numRowsToLoad, 10);
            sparkImageGallery.loadMoreRows(imgGallery, aspectRatios, numRowsToLoad);
          });
        });
      },
      initJustifiedLayout: function initJustifiedLayout(imgGallery, aspectRatios, maxRows) {
        // console.log(aspectRatios);
        var itemPadding = 10;
        var galleryWidth = imgGallery.offsetWidth;
        var layoutGeometry = justifiedLayout(aspectRatios, {
          containerWidth: galleryWidth + itemPadding * 2,
          containerPadding: itemPadding,
          maxNumRows: maxRows,
          showWidows: true
        });
        var galleryItems = imgGallery.querySelectorAll('.spark-image-gallery-item');
        //layoutGeometry.boxes only lists items that should be displayed
        layoutGeometry.boxes.forEach(function (box, i) {
          galleryItems[i].style.display = 'inline-block';
          galleryItems[i].style.width = box.width + 'px';
        });
    
        // hide any containers that don't come back in the layoutGeometry
        if (galleryItems.length > layoutGeometry.boxes.length) {
          imgGallery.querySelector('.spark-image-gallery__load-more').style.display = 'inline-block';
          for (var i = layoutGeometry.boxes.length; i < galleryItems.length; i++) {
            galleryItems[i].style.display = 'none';
            //if it's hidden on resize, then it should no longer be selected
            _sparkImageGalleryItem["default"].closeItem(galleryItems[i]);
          }
        } else {
          imgGallery.querySelector('.spark-image-gallery__load-more').style.display = '';
        }
        //console.log(layoutGeometry);
      },
      loadMoreRows: function loadMoreRows(imgGallery, aspectRatios) {
        var additionalRows = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;
        maxRows += additionalRows;
        sparkImageGallery.initJustifiedLayout(imgGallery, aspectRatios, maxRows);
      }
    };
    var _default = sparkImageGallery;
    exports["default"] = _default;
    
    },{"../mjs-debounce/mjs-debounce.js":10,"../spark-image-gallery-item/spark-image-gallery-item.js":23,"justified-layout":30}],25:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var sparkMultifileUpload = {
      init: function init() {
        [].forEach.call(document.querySelectorAll('.spark-multifile-upload__add-button'), function (addFileButton) {
          var maxFiles = parseInt(addFileButton.parentElement.dataset.maxfiles, 10);
          var uploadInputs = addFileButton.parentElement.querySelectorAll('.spark-input');
          if (isNaN(maxFiles) || uploadInputs.length >= maxFiles) {
            addFileButton.remove();
            return;
          }
          addFileButton.addEventListener('click', function () {
            var uploadInputs = addFileButton.parentElement.querySelectorAll('.spark-input');
            var newUploadLabel = uploadInputs[0].cloneNode(true);
            newUploadLabel.setAttribute('for', newUploadLabel.getAttribute('for') + uploadInputs.length);
            var newUploadInput = newUploadLabel.querySelector('input');
            newUploadInput.id = newUploadLabel.getAttribute('for');
            newUploadInput.value = '';
            addFileButton.parentElement.insertBefore(newUploadLabel, addFileButton);
            if (uploadInputs.length + 1 >= maxFiles) {
              addFileButton.remove();
            }
          });
        });
      }
    };
    var _default = sparkMultifileUpload;
    exports["default"] = _default;
    
    },{}],26:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var sparkOrderFormModule = {
      init: function init() {
        [].forEach.call(document.querySelectorAll('.spark-order-form-module'), function (sparkOrderFormModule) {
          //Click on + or - buttons
          [].forEach.call(sparkOrderFormModule.querySelectorAll('.spark-order-form-module__qbtn'), function (quantityBtn) {
            quantityBtn.addEventListener('click', function () {
              var quantityInput = this.parentElement.querySelector('.spark-input input');
              var isFewerClicked = this.classList.contains('spark-order-form-module__qbtn--fewer');
              var quantityValue = parseInt(quantityInput.value, 10);
              //default to --greater button click
              var minValue = 0;
              var modifier = 1;
              if (isFewerClicked) {
                minValue = 1;
                modifier = -1;
              }
              if (quantityValue >= minValue) {
                quantityInput.value = quantityValue + modifier;
              } else {
                quantityInput.value = 0;
              }
            });
          });
    
          //Click on tile toggles checked state of item
          sparkOrderFormModule.querySelector('.lumen-tile').addEventListener('click', function (e) {
            e.preventDefault();
            var checkbox = this.parentElement.querySelector('input[type="checkbox"]');
            checkbox.checked = !checkbox.checked;
          });
        });
      }
    };
    var _default = sparkOrderFormModule;
    exports["default"] = _default;
    
    },{}],27:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var select = {
      init: function init() {
        var selects = document.querySelectorAll('.spark-select--options-as-url select');
        var _loop = function _loop() {
          var usedMouse = false;
          selects[i].addEventListener('click', function () {
            usedMouse = true;
          });
          selects[i].addEventListener('keydown', function (e) {
            usedMouse = false;
            if (e.keyCode === 13 || e.keyCode === 9) {
              //13 = enter, 9 = tab
              document.location.href = this.options[this.selectedIndex].value;
            }
          });
          selects[i].addEventListener('change', function () {
            if (usedMouse) {
              document.location.href = this.options[this.selectedIndex].value;
            }
          });
        };
        for (var i = 0; i < selects.length; i++) {
          _loop();
        }
      }
    };
    var _default = select;
    exports["default"] = _default;
    
    },{}],28:[function(require,module,exports){
    "use strict";
    
    var _publisherFormAdmin = _interopRequireDefault(require("./libs/publisher-form-admin/_publisher-form-admin.js"));
    var _sparkFeature = _interopRequireDefault(require("./libs/spark-feature/spark-feature.js"));
    var _sparkDrawer = _interopRequireDefault(require("./libs/spark-drawer/_spark-drawer.js"));
    var _lumenVideo = _interopRequireDefault(require("./libs/lumen-video/_lumen-video.js"));
    var _lumenQuote = _interopRequireDefault(require("./libs/lumen-quote/_lumen-quote.js"));
    var _sparkContentActions = _interopRequireDefault(require("./libs/spark-content-actions/_spark-content-actions.js"));
    var _lumenDynamicLayout = _interopRequireDefault(require("./libs/lumen-dynamic-layout/_lumen-dynamic-layout.js"));
    var _sparkSelect = _interopRequireDefault(require("./libs/spark-select/spark-select.js"));
    var _lumenTitleBlock = _interopRequireDefault(require("./libs/lumen-title-block/_lumen-title-block.js"));
    var _sparkImageGallery = _interopRequireDefault(require("./libs/spark-image-gallery/spark-image-gallery.js"));
    var _sparkImageGalleryItem = _interopRequireDefault(require("./libs/spark-image-gallery-item/spark-image-gallery-item.js"));
    var _sparkMultifileUpload = _interopRequireDefault(require("./libs/spark-multifile-upload/spark-multifile-upload.js"));
    var _sparkOrderFormModule = _interopRequireDefault(require("./libs/spark-order-form-module/spark-order-form-module.js"));
    var _lumenImage = _interopRequireDefault(require("./libs/lumen-image/_lumen-image.js"));
    var _lumenSubNav = _interopRequireDefault(require("./libs/lumen-sub-nav/lumen-sub-nav.js"));
    var _search = _interopRequireDefault(require("./search.js"));
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
    //import historify from './libs/primer-historify/primer-historify.js';
    
    if (!window.SITE) window.SITE = {};
    window.SITE.init = function () {
      _lumenVideo["default"].init();
      _sparkDrawer["default"].init();
      _sparkFeature["default"].init();
      _publisherFormAdmin["default"].init();
      _lumenDynamicLayout["default"].init();
      _sparkContentActions["default"].init();
      _lumenQuote["default"].init();
      _sparkSelect["default"].init();
      _lumenTitleBlock["default"].init();
      _sparkImageGallery["default"].init();
      _sparkImageGalleryItem["default"].init();
      _sparkMultifileUpload["default"].init();
      _lumenImage["default"].init();
      _lumenSubNav["default"].init();
      _sparkOrderFormModule["default"].init();
      _search["default"].init();
    };
    window.onload = function () {
      window.digitalData = window.digitalData || [];
      window.digitalDataEvents = {
        pageView: 'Page View'
      };
      var domain = window.location.hostname.split('.')[0] === 'www' ? window.location.hostname.split('.')[1] : window.location.hostname.split('.')[0];
      var path = window.location.pathname.replace(/\//g, '|').replace(/-/g, ' ').substring(1).replace(/\|$/, '');
      window.digitalData.push({
        event: window.digitalDataEvents.pageView,
        page: {
          info: {
            name: "".concat(domain, "|").concat(path || 'home'),
            language: window.platformConfig.dataConfig.lang,
            siteName: 'Church of Jesus Christ'
          },
          category: {
            primary: 'Area Communication Pages',
            type: 'Content'
          }
        }
      });
      if (window.Platform.lang === 'kor') {
        var header = document.querySelector('head');
        var body = document.querySelector('body');
        var meta = document.createElement('meta');
        meta.name = 'naver-site-verification';
        meta.content = '34b6411c77280a18d60668bbf9d131a0fe8acb43';
        header.appendChild(meta);
        var script1 = document.createElement('script');
        script1.type = 'text/javascript';
        script1.src = 'https://wcs.naver.net/wcslog.js';
        var script2 = document.createElement('script');
        script2.type = 'text/javascript';
        script2.innerText = "if (!wcs_add) var wcs_add = {};" + "wcs_add ['wa'] = 'bd921030843eb8';" + "wcs_do ();";
        body.appendChild(script1);
        body.appendChild(script2);
      }
    };
    window.addEventListener('DOMContentLoaded', function DCL() {
      window.platformConfig.searchConfig.searchPath = window.location.origin;
      window.SITE.init();
    
      // historify({
      //     cache: localStorage,
      //     linkScope: '', //site domain or scoped subsection (churchofjesuschrist.org/xxxx/xxxx)
      //     preCallback: function(event){
      //         //pre-historify function (add transition class)
      //     },
      //     postCallback: function(data, url){
      //         //post-historify function (remove transition class, update analytics)
      //     }
      // });
    
      window.removeEventListener('DOMContentLoaded', DCL);
    });
    
    },{"./libs/lumen-dynamic-layout/_lumen-dynamic-layout.js":1,"./libs/lumen-image/_lumen-image.js":2,"./libs/lumen-quote/_lumen-quote.js":3,"./libs/lumen-sub-nav/lumen-sub-nav.js":4,"./libs/lumen-title-block/_lumen-title-block.js":5,"./libs/lumen-video/_lumen-video.js":6,"./libs/publisher-form-admin/_publisher-form-admin.js":19,"./libs/spark-content-actions/_spark-content-actions.js":20,"./libs/spark-drawer/_spark-drawer.js":21,"./libs/spark-feature/spark-feature.js":22,"./libs/spark-image-gallery-item/spark-image-gallery-item.js":23,"./libs/spark-image-gallery/spark-image-gallery.js":24,"./libs/spark-multifile-upload/spark-multifile-upload.js":25,"./libs/spark-order-form-module/spark-order-form-module.js":26,"./libs/spark-select/spark-select.js":27,"./search.js":29}],29:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _mjsQueryString = _interopRequireDefault(require("./libs/mjs-query-string/mjs-query-string.js"));
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
    var acpSearch = {
      init: function init() {
        if (!document.querySelector('.acp-results-template')) {
          return false;
        }
        var waitForPlatform = setInterval(function () {
          var Platform = {};
          if (typeof Platform.theInputValue === 'function') {
            if ((0, _mjsQueryString["default"])('query').val.length) {
              Platform.theInputValue((0, _mjsQueryString["default"])('query').val.replace(/\+/g, ' '));
            }
            Platform.theInputFocus();
            clearInterval(waitForPlatform);
          }
        }, 1);
      }
    };
    window.keepFacet = function () {
      var local = (0, _mjsQueryString["default"])('local').val;
      var searchInput = document.createElement('input');
      searchInput.setAttribute('type', 'hidden');
      searchInput.setAttribute('name', 'local');
      searchInput.setAttribute('value', local);
      searchInput.classList.add('local');
      document.querySelector('.pf-search').appendChild(searchInput);
    };
    window.removeFacet = function () {
      document.querySelector('.local').remove();
    };
    var _default = acpSearch;
    exports["default"] = _default;
    
    },{"./libs/mjs-query-string/mjs-query-string.js":14}],30:[function(require,module,exports){
    /*!
     * Copyright 2019 SmugMug, Inc.
     * Licensed under the terms of the MIT license. Please see LICENSE file in the project root for terms.
     * @license
     */
    
    'use strict';
    
    var Row = require('./row');
    
    /**
     * Create a new, empty row.
     *
     * @method createNewRow
     * @param layoutConfig {Object} The layout configuration
     * @param layoutData {Object} The current state of the layout
     * @return A new, empty row of the type specified by this layout.
     */
    
    function createNewRow(layoutConfig, layoutData) {
    
        var isBreakoutRow;
    
        // Work out if this is a full width breakout row
        if (layoutConfig.fullWidthBreakoutRowCadence !== false) {
            if (((layoutData._rows.length + 1) % layoutConfig.fullWidthBreakoutRowCadence) === 0) {
                isBreakoutRow = true;
            }
        }
    
        return new Row({
            top: layoutData._containerHeight,
            left: layoutConfig.containerPadding.left,
            width: layoutConfig.containerWidth - layoutConfig.containerPadding.left - layoutConfig.containerPadding.right,
            spacing: layoutConfig.boxSpacing.horizontal,
            targetRowHeight: layoutConfig.targetRowHeight,
            targetRowHeightTolerance: layoutConfig.targetRowHeightTolerance,
            edgeCaseMinRowHeight: 0.5 * layoutConfig.targetRowHeight,
            edgeCaseMaxRowHeight: 2 * layoutConfig.targetRowHeight,
            rightToLeft: false,
            isBreakoutRow: isBreakoutRow,
            widowLayoutStyle: layoutConfig.widowLayoutStyle
        });
    }
    
    /**
     * Add a completed row to the layout.
     * Note: the row must have already been completed.
     *
     * @method addRow
     * @param layoutConfig {Object} The layout configuration
     * @param layoutData {Object} The current state of the layout
     * @param row {Row} The row to add.
     * @return {Array} Each item added to the row.
     */
    
    function addRow(layoutConfig, layoutData, row) {
    
        layoutData._rows.push(row);
        layoutData._layoutItems = layoutData._layoutItems.concat(row.getItems());
    
        // Increment the container height
        layoutData._containerHeight += row.height + layoutConfig.boxSpacing.vertical;
    
        return row.items;
    }
    
    /**
     * Calculate the current layout for all items in the list that require layout.
     * "Layout" means geometry: position within container and size
     *
     * @method computeLayout
     * @param layoutConfig {Object} The layout configuration
     * @param layoutData {Object} The current state of the layout
     * @param itemLayoutData {Array} Array of items to lay out, with data required to lay out each item
     * @return {Object} The newly-calculated layout, containing the new container height, and lists of layout items
     */
    
    function computeLayout(layoutConfig, layoutData, itemLayoutData) {
    
        var laidOutItems = [],
            itemAdded,
            currentRow,
            nextToLastRowHeight;
    
        // Apply forced aspect ratio if specified, and set a flag.
        if (layoutConfig.forceAspectRatio) {
            itemLayoutData.forEach(function (itemData) {
                itemData.forcedAspectRatio = true;
                itemData.aspectRatio = layoutConfig.forceAspectRatio;
            });
        }
    
        // Loop through the items
        itemLayoutData.some(function (itemData, i) {
    
            if (isNaN(itemData.aspectRatio)) {
                throw new Error("Item " + i + " has an invalid aspect ratio");
            }
    
            // If not currently building up a row, make a new one.
            if (!currentRow) {
                currentRow = createNewRow(layoutConfig, layoutData);
            }
    
            // Attempt to add item to the current row.
            itemAdded = currentRow.addItem(itemData);
    
            if (currentRow.isLayoutComplete()) {
    
                // Row is filled; add it and start a new one
                laidOutItems = laidOutItems.concat(addRow(layoutConfig, layoutData, currentRow));
    
                if (layoutData._rows.length >= layoutConfig.maxNumRows) {
                    currentRow = null;
                    return true;
                }
    
                currentRow = createNewRow(layoutConfig, layoutData);
    
                // Item was rejected; add it to its own row
                if (!itemAdded) {
    
                    itemAdded = currentRow.addItem(itemData);
    
                    if (currentRow.isLayoutComplete()) {
    
                        // If the rejected item fills a row on its own, add the row and start another new one
                        laidOutItems = laidOutItems.concat(addRow(layoutConfig, layoutData, currentRow));
                        if (layoutData._rows.length >= layoutConfig.maxNumRows) {
                            currentRow = null;
                            return true;
                        }
                        currentRow = createNewRow(layoutConfig, layoutData);
                    }
                }
            }
    
        });
    
        // Handle any leftover content (orphans) depending on where they lie
        // in this layout update, and in the total content set.
        if (currentRow && currentRow.getItems().length && layoutConfig.showWidows) {
    
            // Last page of all content or orphan suppression is suppressed; lay out orphans.
            if (layoutData._rows.length) {
    
                // Only Match previous row's height if it exists and it isn't a breakout row
                if (layoutData._rows[layoutData._rows.length - 1].isBreakoutRow) {
                    nextToLastRowHeight = layoutData._rows[layoutData._rows.length - 1].targetRowHeight;
                } else {
                    nextToLastRowHeight = layoutData._rows[layoutData._rows.length - 1].height;
                }
    
                currentRow.forceComplete(false, nextToLastRowHeight);
    
            } else {
    
                // ...else use target height if there is no other row height to reference.
                currentRow.forceComplete(false);
    
            }
    
            laidOutItems = laidOutItems.concat(addRow(layoutConfig, layoutData, currentRow));
            layoutConfig._widowCount = currentRow.getItems().length;
    
        }
    
        // We need to clean up the bottom container padding
        // First remove the height added for box spacing
        layoutData._containerHeight = layoutData._containerHeight - layoutConfig.boxSpacing.vertical;
        // Then add our bottom container padding
        layoutData._containerHeight = layoutData._containerHeight + layoutConfig.containerPadding.bottom;
    
        return {
            containerHeight: layoutData._containerHeight,
            widowCount: layoutConfig._widowCount,
            boxes: layoutData._layoutItems
        };
    
    }
    
    /**
     * Takes in a bunch of box data and config. Returns
     * geometry to lay them out in a justified view.
     *
     * @method covertSizesToAspectRatios
     * @param sizes {Array} Array of objects with widths and heights
     * @return {Array} A list of aspect ratios
     */
    
    module.exports = function (input, config) {
        var layoutConfig = {};
        var layoutData = {};
    
        // Defaults
        var defaults = {
            containerWidth: 1060,
            containerPadding: 10,
            boxSpacing: 10,
            targetRowHeight: 320,
            targetRowHeightTolerance: 0.25,
            maxNumRows: Number.POSITIVE_INFINITY,
            forceAspectRatio: false,
            showWidows: true,
            fullWidthBreakoutRowCadence: false,
            widowLayoutStyle: 'left'
        };
    
        var containerPadding = {};
        var boxSpacing = {};
    
        config = config || {};
    
        // Merge defaults and config passed in
        layoutConfig = Object.assign(defaults, config);
    
        // Sort out padding and spacing values
        containerPadding.top = (!isNaN(parseFloat(layoutConfig.containerPadding.top))) ? layoutConfig.containerPadding.top : layoutConfig.containerPadding;
        containerPadding.right = (!isNaN(parseFloat(layoutConfig.containerPadding.right))) ? layoutConfig.containerPadding.right : layoutConfig.containerPadding;
        containerPadding.bottom = (!isNaN(parseFloat(layoutConfig.containerPadding.bottom))) ? layoutConfig.containerPadding.bottom : layoutConfig.containerPadding;
        containerPadding.left = (!isNaN(parseFloat(layoutConfig.containerPadding.left))) ? layoutConfig.containerPadding.left : layoutConfig.containerPadding;
        boxSpacing.horizontal = (!isNaN(parseFloat(layoutConfig.boxSpacing.horizontal))) ? layoutConfig.boxSpacing.horizontal : layoutConfig.boxSpacing;
        boxSpacing.vertical = (!isNaN(parseFloat(layoutConfig.boxSpacing.vertical))) ? layoutConfig.boxSpacing.vertical : layoutConfig.boxSpacing;
    
        layoutConfig.containerPadding = containerPadding;
        layoutConfig.boxSpacing = boxSpacing;
    
        // Local
        layoutData._layoutItems = [];
        layoutData._awakeItems = [];
        layoutData._inViewportItems = [];
        layoutData._leadingOrphans = [];
        layoutData._trailingOrphans = [];
        layoutData._containerHeight = layoutConfig.containerPadding.top;
        layoutData._rows = [];
        layoutData._orphans = [];
        layoutConfig._widowCount = 0;
    
        // Convert widths and heights to aspect ratios if we need to
        return computeLayout(layoutConfig, layoutData, input.map(function (item) {
            if (item.width && item.height) {
                return { aspectRatio: item.width / item.height };
            } else {
                return { aspectRatio: item };
            }
        }));
    };
    
    },{"./row":31}],31:[function(require,module,exports){
    /*!
     * Copyright 2019 SmugMug, Inc.
     * Licensed under the terms of the MIT license. Please see LICENSE file in the project root for terms.
     * @license
     */
    
    /**
     * Row
     * Wrapper for each row in a justified layout.
     * Stores relevant values and provides methods for calculating layout of individual rows.
     *
     * @param {Object} layoutConfig - The same as that passed
     * @param {Object} Initialization parameters. The following are all required:
     * @param params.top {Number} Top of row, relative to container
     * @param params.left {Number} Left side of row relative to container (equal to container left padding)
     * @param params.width {Number} Width of row, not including container padding
     * @param params.spacing {Number} Horizontal spacing between items
     * @param params.targetRowHeight {Number} Layout algorithm will aim for this row height
     * @param params.targetRowHeightTolerance {Number} Row heights may vary +/- (`targetRowHeight` x `targetRowHeightTolerance`)
     * @param params.edgeCaseMinRowHeight {Number} Absolute minimum row height for edge cases that cannot be resolved within tolerance.
     * @param params.edgeCaseMaxRowHeight {Number} Absolute maximum row height for edge cases that cannot be resolved within tolerance.
     * @param params.isBreakoutRow {Boolean} Is this row in particular one of those breakout rows? Always false if it's not that kind of photo list
     * @param params.widowLayoutStyle {String} If widows are visible, how should they be laid out?
     * @constructor
     */
    
    var Row = module.exports = function (params) {
    
        // Top of row, relative to container
        this.top = params.top;
    
        // Left side of row relative to container (equal to container left padding)
        this.left = params.left;
    
        // Width of row, not including container padding
        this.width = params.width;
    
        // Horizontal spacing between items
        this.spacing = params.spacing;
    
        // Row height calculation values
        this.targetRowHeight = params.targetRowHeight;
        this.targetRowHeightTolerance = params.targetRowHeightTolerance;
        this.minAspectRatio = this.width / params.targetRowHeight * (1 - params.targetRowHeightTolerance);
        this.maxAspectRatio = this.width / params.targetRowHeight * (1 + params.targetRowHeightTolerance);
    
        // Edge case row height minimum/maximum
        this.edgeCaseMinRowHeight = params.edgeCaseMinRowHeight;
        this.edgeCaseMaxRowHeight = params.edgeCaseMaxRowHeight;
    
        // Widow layout direction
        this.widowLayoutStyle = params.widowLayoutStyle;
    
        // Full width breakout rows
        this.isBreakoutRow = params.isBreakoutRow;
    
        // Store layout data for each item in row
        this.items = [];
    
        // Height remains at 0 until it's been calculated
        this.height = 0;
    
    };
    
    Row.prototype = {
    
        /**
         * Attempt to add a single item to the row.
         * This is the heart of the justified algorithm.
         * This method is direction-agnostic; it deals only with sizes, not positions.
         *
         * If the item fits in the row, without pushing row height beyond min/max tolerance,
         * the item is added and the method returns true.
         *
         * If the item leaves row height too high, there may be room to scale it down and add another item.
         * In this case, the item is added and the method returns true, but the row is incomplete.
         *
         * If the item leaves row height too short, there are too many items to fit within tolerance.
         * The method will either accept or reject the new item, favoring the resulting row height closest to within tolerance.
         * If the item is rejected, left/right padding will be required to fit the row height within tolerance;
         * if the item is accepted, top/bottom cropping will be required to fit the row height within tolerance.
         *
         * @method addItem
         * @param itemData {Object} Item layout data, containing item aspect ratio.
         * @return {Boolean} True if successfully added; false if rejected.
         */
    
        addItem: function (itemData) {
    
            var newItems = this.items.concat(itemData),
                // Calculate aspect ratios for items only; exclude spacing
                rowWidthWithoutSpacing = this.width - (newItems.length - 1) * this.spacing,
                newAspectRatio = newItems.reduce(function (sum, item) {
                    return sum + item.aspectRatio;
                }, 0),
                targetAspectRatio = rowWidthWithoutSpacing / this.targetRowHeight,
                previousRowWidthWithoutSpacing,
                previousAspectRatio,
                previousTargetAspectRatio;
    
            // Handle big full-width breakout photos if we're doing them
            if (this.isBreakoutRow) {
                // Only do it if there's no other items in this row
                if (this.items.length === 0) {
                    // Only go full width if this photo is a square or landscape
                    if (itemData.aspectRatio >= 1) {
                        // Close out the row with a full width photo
                        this.items.push(itemData);
                        this.completeLayout(rowWidthWithoutSpacing / itemData.aspectRatio, 'justify');
                        return true;
                    }
                }
            }
    
            if (newAspectRatio < this.minAspectRatio) {
    
                // New aspect ratio is too narrow / scaled row height is too tall.
                // Accept this item and leave row open for more items.
    
                this.items.push(Object.assign({}, itemData));
                return true;
    
            } else if (newAspectRatio > this.maxAspectRatio) {
    
                // New aspect ratio is too wide / scaled row height will be too short.
                // Accept item if the resulting aspect ratio is closer to target than it would be without the item.
                // NOTE: Any row that falls into this block will require cropping/padding on individual items.
    
                if (this.items.length === 0) {
    
                    // When there are no existing items, force acceptance of the new item and complete the layout.
                    // This is the pano special case.
                    this.items.push(Object.assign({}, itemData));
                    this.completeLayout(rowWidthWithoutSpacing / newAspectRatio, 'justify');
                    return true;
    
                }
    
                // Calculate width/aspect ratio for row before adding new item
                previousRowWidthWithoutSpacing = this.width - (this.items.length - 1) * this.spacing;
                previousAspectRatio = this.items.reduce(function (sum, item) {
                    return sum + item.aspectRatio;
                }, 0);
                previousTargetAspectRatio = previousRowWidthWithoutSpacing / this.targetRowHeight;
    
                if (Math.abs(newAspectRatio - targetAspectRatio) > Math.abs(previousAspectRatio - previousTargetAspectRatio)) {
    
                    // Row with new item is us farther away from target than row without; complete layout and reject item.
                    this.completeLayout(previousRowWidthWithoutSpacing / previousAspectRatio, 'justify');
                    return false;
    
                } else {
    
                    // Row with new item is us closer to target than row without;
                    // accept the new item and complete the row layout.
                    this.items.push(Object.assign({}, itemData));
                    this.completeLayout(rowWidthWithoutSpacing / newAspectRatio, 'justify');
                    return true;
    
                }
    
            } else {
    
                // New aspect ratio / scaled row height is within tolerance;
                // accept the new item and complete the row layout.
                this.items.push(Object.assign({}, itemData));
                this.completeLayout(rowWidthWithoutSpacing / newAspectRatio, 'justify');
                return true;
    
            }
    
        },
    
        /**
         * Check if a row has completed its layout.
         *
         * @method isLayoutComplete
         * @return {Boolean} True if complete; false if not.
         */
    
        isLayoutComplete: function () {
            return this.height > 0;
        },
    
        /**
         * Set row height and compute item geometry from that height.
         * Will justify items within the row unless instructed not to.
         *
         * @method completeLayout
         * @param newHeight {Number} Set row height to this value.
         * @param widowLayoutStyle {String} How should widows display? Supported: left | justify | center
         */
    
        completeLayout: function (newHeight, widowLayoutStyle) {
    
            var itemWidthSum = this.left,
                rowWidthWithoutSpacing = this.width - (this.items.length - 1) * this.spacing,
                clampedToNativeRatio,
                clampedHeight,
                errorWidthPerItem,
                roundedCumulativeErrors,
                singleItemGeometry,
                centerOffset;
    
            // Justify unless explicitly specified otherwise.
            if (typeof widowLayoutStyle === 'undefined' || ['justify', 'center', 'left'].indexOf(widowLayoutStyle) < 0) {
                widowLayoutStyle = 'left';
            }
    
            // Clamp row height to edge case minimum/maximum.
            clampedHeight = Math.max(this.edgeCaseMinRowHeight, Math.min(newHeight, this.edgeCaseMaxRowHeight));
    
            if (newHeight !== clampedHeight) {
    
                // If row height was clamped, the resulting row/item aspect ratio will be off,
                // so force it to fit the width (recalculate aspectRatio to match clamped height).
                // NOTE: this will result in cropping/padding commensurate to the amount of clamping.
                this.height = clampedHeight;
                clampedToNativeRatio = (rowWidthWithoutSpacing / clampedHeight) / (rowWidthWithoutSpacing / newHeight);
    
            } else {
    
                // If not clamped, leave ratio at 1.0.
                this.height = newHeight;
                clampedToNativeRatio = 1.0;
    
            }
    
            // Compute item geometry based on newHeight.
            this.items.forEach(function (item) {
    
                item.top = this.top;
                item.width = item.aspectRatio * this.height * clampedToNativeRatio;
                item.height = this.height;
    
                // Left-to-right.
                // TODO right to left
                // item.left = this.width - itemWidthSum - item.width;
                item.left = itemWidthSum;
    
                // Increment width.
                itemWidthSum += item.width + this.spacing;
    
            }, this);
    
            // If specified, ensure items fill row and distribute error
            // caused by rounding width and height across all items.
            if (widowLayoutStyle === 'justify') {
    
                itemWidthSum -= (this.spacing + this.left);
    
                errorWidthPerItem = (itemWidthSum - this.width) / this.items.length;
                roundedCumulativeErrors = this.items.map(function (item, i) {
                    return Math.round((i + 1) * errorWidthPerItem);
                });
    
    
                if (this.items.length === 1) {
    
                    // For rows with only one item, adjust item width to fill row.
                    singleItemGeometry = this.items[0];
                    singleItemGeometry.width -= Math.round(errorWidthPerItem);
    
                } else {
    
                    // For rows with multiple items, adjust item width and shift items to fill the row,
                    // while maintaining equal spacing between items in the row.
                    this.items.forEach(function (item, i) {
                        if (i > 0) {
                            item.left -= roundedCumulativeErrors[i - 1];
                            item.width -= (roundedCumulativeErrors[i] - roundedCumulativeErrors[i - 1]);
                        } else {
                            item.width -= roundedCumulativeErrors[i];
                        }
                    });
    
                }
    
            } else if (widowLayoutStyle === 'center') {
    
                // Center widows
                centerOffset = (this.width - itemWidthSum) / 2;
    
                this.items.forEach(function (item) {
                    item.left += centerOffset + this.spacing;
                }, this);
    
            }
    
        },
    
        /**
         * Force completion of row layout with current items.
         *
         * @method forceComplete
         * @param fitToWidth {Boolean} Stretch current items to fill the row width.
         *                             This will likely result in padding.
         * @param fitToWidth {Number}
         */
    
        forceComplete: function (fitToWidth, rowHeight) {
    
            // TODO Handle fitting to width
            // var rowWidthWithoutSpacing = this.width - (this.items.length - 1) * this.spacing,
            // 	currentAspectRatio = this.items.reduce(function (sum, item) {
            // 		return sum + item.aspectRatio;
            // 	}, 0);
    
            if (typeof rowHeight === 'number') {
    
                this.completeLayout(rowHeight, this.widowLayoutStyle);
    
            } else {
    
                // Complete using target row height.
                this.completeLayout(this.targetRowHeight, this.widowLayoutStyle);
            }
    
        },
    
        /**
         * Return layout data for items within row.
         * Note: returns actual list, not a copy.
         *
         * @method getItems
         * @return Layout data for items within row.
         */
    
        getItems: function () {
            return this.items;
        }
    
    };
    
    },{}],32:[function(require,module,exports){
    (function (process){(function (){
    // Generated by CoffeeScript 1.12.2
    (function() {
      var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;
    
      if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
        module.exports = function() {
          return performance.now();
        };
      } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
        module.exports = function() {
          return (getNanoSeconds() - nodeLoadTime) / 1e6;
        };
        hrtime = process.hrtime;
        getNanoSeconds = function() {
          var hr;
          hr = hrtime();
          return hr[0] * 1e9 + hr[1];
        };
        moduleLoadTime = getNanoSeconds();
        upTime = process.uptime() * 1e9;
        nodeLoadTime = moduleLoadTime - upTime;
      } else if (Date.now) {
        module.exports = function() {
          return Date.now() - loadTime;
        };
        loadTime = Date.now();
      } else {
        module.exports = function() {
          return new Date().getTime() - loadTime;
        };
        loadTime = new Date().getTime();
      }
    
    }).call(this);
    
    
    
    }).call(this)}).call(this,require('_process'))
    },{"_process":33}],33:[function(require,module,exports){
    // shim for using process in browser
    var process = module.exports = {};
    
    // cached from whatever global is present so that test runners that stub it
    // don't break things.  But we need to wrap it in a try catch in case it is
    // wrapped in strict mode code which doesn't define any globals.  It's inside a
    // function because try/catches deoptimize in certain engines.
    
    var cachedSetTimeout;
    var cachedClearTimeout;
    
    function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
    }
    function defaultClearTimeout () {
        throw new Error('clearTimeout has not been defined');
    }
    (function () {
        try {
            if (typeof setTimeout === 'function') {
                cachedSetTimeout = setTimeout;
            } else {
                cachedSetTimeout = defaultSetTimout;
            }
        } catch (e) {
            cachedSetTimeout = defaultSetTimout;
        }
        try {
            if (typeof clearTimeout === 'function') {
                cachedClearTimeout = clearTimeout;
            } else {
                cachedClearTimeout = defaultClearTimeout;
            }
        } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
        }
    } ())
    function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
        } catch(e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                return cachedSetTimeout.call(null, fun, 0);
            } catch(e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                return cachedSetTimeout.call(this, fun, 0);
            }
        }
    
    
    }
    function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
        } catch (e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                return cachedClearTimeout.call(null, marker);
            } catch (e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                return cachedClearTimeout.call(this, marker);
            }
        }
    
    
    
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    
    function cleanUpNextTick() {
        if (!draining || !currentQueue) {
            return;
        }
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }
    
    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
    
        var len = queue.length;
        while(len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
    }
    
    process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
        }
    };
    
    // v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    process.title = 'browser';
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = ''; // empty string to avoid regexp issues
    process.versions = {};
    
    function noop() {}
    
    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;
    process.prependListener = noop;
    process.prependOnceListener = noop;
    
    process.listeners = function (name) { return [] }
    
    process.binding = function (name) {
        throw new Error('process.binding is not supported');
    };
    
    process.cwd = function () { return '/' };
    process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
    };
    process.umask = function() { return 0; };
    
    },{}],34:[function(require,module,exports){
    (function (global){(function (){
    var now = require('performance-now')
      , root = typeof window === 'undefined' ? global : window
      , vendors = ['moz', 'webkit']
      , suffix = 'AnimationFrame'
      , raf = root['request' + suffix]
      , caf = root['cancel' + suffix] || root['cancelRequest' + suffix]
    
    for(var i = 0; !raf && i < vendors.length; i++) {
      raf = root[vendors[i] + 'Request' + suffix]
      caf = root[vendors[i] + 'Cancel' + suffix]
          || root[vendors[i] + 'CancelRequest' + suffix]
    }
    
    // Some versions of FF have rAF but not cAF
    if(!raf || !caf) {
      var last = 0
        , id = 0
        , queue = []
        , frameDuration = 1000 / 60
    
      raf = function(callback) {
        if(queue.length === 0) {
          var _now = now()
            , next = Math.max(0, frameDuration - (_now - last))
          last = next + _now
          setTimeout(function() {
            var cp = queue.slice(0)
            // Clear queue here to prevent
            // callbacks from appending listeners
            // to the current frame's queue
            queue.length = 0
            for(var i = 0; i < cp.length; i++) {
              if(!cp[i].cancelled) {
                try{
                  cp[i].callback(last)
                } catch(e) {
                  setTimeout(function() { throw e }, 0)
                }
              }
            }
          }, Math.round(next))
        }
        queue.push({
          handle: ++id,
          callback: callback,
          cancelled: false
        })
        return id
      }
    
      caf = function(handle) {
        for(var i = 0; i < queue.length; i++) {
          if(queue[i].handle === handle) {
            queue[i].cancelled = true
          }
        }
      }
    }
    
    module.exports = function(fn) {
      // Wrap in a new function to prevent
      // `cancel` potentially being assigned
      // to the native rAF function
      return raf.call(root, fn)
    }
    module.exports.cancel = function() {
      caf.apply(root, arguments)
    }
    module.exports.polyfill = function(object) {
      if (!object) {
        object = root;
      }
      object.requestAnimationFrame = raf
      object.cancelAnimationFrame = caf
    }
    
    }).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    },{"performance-now":32}],35:[function(require,module,exports){
    // easing functions from "Tween.js"
    exports.linear = function(n){
      return n;
    };
    
    exports.inQuad = function(n){
      return n * n;
    };
    
    exports.outQuad = function(n){
      return n * (2 - n);
    };
    
    exports.inOutQuad = function(n){
      n *= 2;
      if (n < 1) return 0.5 * n * n;
      return - 0.5 * (--n * (n - 2) - 1);
    };
    
    exports.inCube = function(n){
      return n * n * n;
    };
    
    exports.outCube = function(n){
      return --n * n * n + 1;
    };
    
    exports.inOutCube = function(n){
      n *= 2;
      if (n < 1) return 0.5 * n * n * n;
      return 0.5 * ((n -= 2 ) * n * n + 2);
    };
    
    exports.inQuart = function(n){
      return n * n * n * n;
    };
    
    exports.outQuart = function(n){
      return 1 - (--n * n * n * n);
    };
    
    exports.inOutQuart = function(n){
      n *= 2;
      if (n < 1) return 0.5 * n * n * n * n;
      return -0.5 * ((n -= 2) * n * n * n - 2);
    };
    
    exports.inQuint = function(n){
      return n * n * n * n * n;
    }
    
    exports.outQuint = function(n){
      return --n * n * n * n * n + 1;
    }
    
    exports.inOutQuint = function(n){
      n *= 2;
      if (n < 1) return 0.5 * n * n * n * n * n;
      return 0.5 * ((n -= 2) * n * n * n * n + 2);
    };
    
    exports.inSine = function(n){
      return 1 - Math.cos(n * Math.PI / 2 );
    };
    
    exports.outSine = function(n){
      return Math.sin(n * Math.PI / 2);
    };
    
    exports.inOutSine = function(n){
      return .5 * (1 - Math.cos(Math.PI * n));
    };
    
    exports.inExpo = function(n){
      return 0 == n ? 0 : Math.pow(1024, n - 1);
    };
    
    exports.outExpo = function(n){
      return 1 == n ? n : 1 - Math.pow(2, -10 * n);
    };
    
    exports.inOutExpo = function(n){
      if (0 == n) return 0;
      if (1 == n) return 1;
      if ((n *= 2) < 1) return .5 * Math.pow(1024, n - 1);
      return .5 * (-Math.pow(2, -10 * (n - 1)) + 2);
    };
    
    exports.inCirc = function(n){
      return 1 - Math.sqrt(1 - n * n);
    };
    
    exports.outCirc = function(n){
      return Math.sqrt(1 - (--n * n));
    };
    
    exports.inOutCirc = function(n){
      n *= 2
      if (n < 1) return -0.5 * (Math.sqrt(1 - n * n) - 1);
      return 0.5 * (Math.sqrt(1 - (n -= 2) * n) + 1);
    };
    
    exports.inBack = function(n){
      var s = 1.70158;
      return n * n * (( s + 1 ) * n - s);
    };
    
    exports.outBack = function(n){
      var s = 1.70158;
      return --n * n * ((s + 1) * n + s) + 1;
    };
    
    exports.inOutBack = function(n){
      var s = 1.70158 * 1.525;
      if ( ( n *= 2 ) < 1 ) return 0.5 * ( n * n * ( ( s + 1 ) * n - s ) );
      return 0.5 * ( ( n -= 2 ) * n * ( ( s + 1 ) * n + s ) + 2 );
    };
    
    exports.inBounce = function(n){
      return 1 - exports.outBounce(1 - n);
    };
    
    exports.outBounce = function(n){
      if ( n < ( 1 / 2.75 ) ) {
        return 7.5625 * n * n;
      } else if ( n < ( 2 / 2.75 ) ) {
        return 7.5625 * ( n -= ( 1.5 / 2.75 ) ) * n + 0.75;
      } else if ( n < ( 2.5 / 2.75 ) ) {
        return 7.5625 * ( n -= ( 2.25 / 2.75 ) ) * n + 0.9375;
      } else {
        return 7.5625 * ( n -= ( 2.625 / 2.75 ) ) * n + 0.984375;
      }
    };
    
    exports.inOutBounce = function(n){
      if (n < .5) return exports.inBounce(n * 2) * .5;
      return exports.outBounce(n * 2 - 1) * .5 + .5;
    };
    
    exports.inElastic = function(n){
      var s, a = 0.1, p = 0.4;
      if ( n === 0 ) return 0;
      if ( n === 1 ) return 1;
      if ( !a || a < 1 ) { a = 1; s = p / 4; }
      else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
      return - ( a * Math.pow( 2, 10 * ( n -= 1 ) ) * Math.sin( ( n - s ) * ( 2 * Math.PI ) / p ) );
    };
    
    exports.outElastic = function(n){
      var s, a = 0.1, p = 0.4;
      if ( n === 0 ) return 0;
      if ( n === 1 ) return 1;
      if ( !a || a < 1 ) { a = 1; s = p / 4; }
      else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
      return ( a * Math.pow( 2, - 10 * n) * Math.sin( ( n - s ) * ( 2 * Math.PI ) / p ) + 1 );
    };
    
    exports.inOutElastic = function(n){
      var s, a = 0.1, p = 0.4;
      if ( n === 0 ) return 0;
      if ( n === 1 ) return 1;
      if ( !a || a < 1 ) { a = 1; s = p / 4; }
      else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
      if ( ( n *= 2 ) < 1 ) return - 0.5 * ( a * Math.pow( 2, 10 * ( n -= 1 ) ) * Math.sin( ( n - s ) * ( 2 * Math.PI ) / p ) );
      return a * Math.pow( 2, -10 * ( n -= 1 ) ) * Math.sin( ( n - s ) * ( 2 * Math.PI ) / p ) * 0.5 + 1;
    };
    
    // aliases
    exports['in-quad'] = exports.inQuad;
    exports['out-quad'] = exports.outQuad;
    exports['in-out-quad'] = exports.inOutQuad;
    exports['in-cube'] = exports.inCube;
    exports['out-cube'] = exports.outCube;
    exports['in-out-cube'] = exports.inOutCube;
    exports['in-quart'] = exports.inQuart;
    exports['out-quart'] = exports.outQuart;
    exports['in-out-quart'] = exports.inOutQuart;
    exports['in-quint'] = exports.inQuint;
    exports['out-quint'] = exports.outQuint;
    exports['in-out-quint'] = exports.inOutQuint;
    exports['in-sine'] = exports.inSine;
    exports['out-sine'] = exports.outSine;
    exports['in-out-sine'] = exports.inOutSine;
    exports['in-expo'] = exports.inExpo;
    exports['out-expo'] = exports.outExpo;
    exports['in-out-expo'] = exports.inOutExpo;
    exports['in-circ'] = exports.inCirc;
    exports['out-circ'] = exports.outCirc;
    exports['in-out-circ'] = exports.inOutCirc;
    exports['in-back'] = exports.inBack;
    exports['out-back'] = exports.outBack;
    exports['in-out-back'] = exports.inOutBack;
    exports['in-bounce'] = exports.inBounce;
    exports['out-bounce'] = exports.outBounce;
    exports['in-out-bounce'] = exports.inOutBounce;
    exports['in-elastic'] = exports.inElastic;
    exports['out-elastic'] = exports.outElastic;
    exports['in-out-elastic'] = exports.inOutElastic;
    
    },{}],36:[function(require,module,exports){
    function Emitter(obj) {
      if (obj) return mixin(obj);
    };
    
    function mixin(obj) {
      for (var key in Emitter.prototype) {
        obj[key] = Emitter.prototype[key];
      }
      return obj;
    }
    
    Emitter.prototype.on =
    Emitter.prototype.addEventListener = function(event, fn){
      this._callbacks = this._callbacks || {};
      (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
        .push(fn);
      return this;
    };
    
    Emitter.prototype.once = function(event, fn){
      function on() {
        this.off(event, on);
        fn.apply(this, arguments);
      }
    
      on.fn = fn;
      this.on(event, on);
      return this;
    };
    
    Emitter.prototype.off =
    Emitter.prototype.removeListener =
    Emitter.prototype.removeAllListeners =
    Emitter.prototype.removeEventListener = function(event, fn){
      this._callbacks = this._callbacks || {};
    
      // all
      if (0 == arguments.length) {
        this._callbacks = {};
        return this;
      }
    
      // specific event
      var callbacks = this._callbacks['$' + event];
      if (!callbacks) return this;
    
      // remove all handlers
      if (1 == arguments.length) {
        delete this._callbacks['$' + event];
        return this;
      }
    
      // remove specific handler
      var cb;
      for (var i = 0; i < callbacks.length; i++) {
        cb = callbacks[i];
        if (cb === fn || cb.fn === fn) {
          callbacks.splice(i, 1);
          break;
        }
      }
    
      // Remove event specific arrays for event types that no
      // one is subscribed for to avoid memory leak.
      if (callbacks.length === 0) {
        delete this._callbacks['$' + event];
      }
    
      return this;
    };
    
    Emitter.prototype.emit = function(event){
      this._callbacks = this._callbacks || {};
      var args = [].slice.call(arguments, 1)
        , callbacks = this._callbacks['$' + event];
    
      if (callbacks) {
        callbacks = callbacks.slice(0);
        for (var i = 0, len = callbacks.length; i < len; ++i) {
          callbacks[i].apply(this, args);
        }
      }
    
      return this;
    };
    
    Emitter.prototype.listeners = function(event){
      this._callbacks = this._callbacks || {};
      return this._callbacks['$' + event] || [];
    };
    
    Emitter.prototype.hasListeners = function(event){
      return !! this.listeners(event).length;
    };
    
    if (typeof module !== 'undefined') {
      module.exports = Emitter;
    }
    
    },{}],37:[function(require,module,exports){
    var scroll = require('./scroll-to');
    
    function calculateScrollOffset(elem, additionalOffset, alignment) {
      var body = document.body,
          html = document.documentElement;
    
      var elemRect = elem.getBoundingClientRect();
      var clientHeight = html.clientHeight;
      var documentHeight = Math.max( body.scrollHeight, body.offsetHeight,
                                     html.clientHeight, html.scrollHeight, html.offsetHeight );
    
      additionalOffset = additionalOffset || 0;
    
      var scrollPosition;
      if (alignment === 'bottom') {
        scrollPosition = elemRect.bottom - clientHeight;
      } else if (alignment === 'middle') {
        scrollPosition = elemRect.bottom - clientHeight / 2 - elemRect.height / 2;
      } else { // top and default
        scrollPosition = elemRect.top;
      }
    
      var maxScrollPosition = documentHeight - clientHeight;
      return Math.min(scrollPosition + additionalOffset + window.pageYOffset,
                      maxScrollPosition);
    }
    
    module.exports = function (elem, options) {
      options = options || {};
      if (typeof elem === 'string') elem = document.querySelector(elem);
      if (elem) return scroll(0, calculateScrollOffset(elem, options.offset, options.align), options);
    };
    
    },{"./scroll-to":38}],38:[function(require,module,exports){
    var Tween = require('./tween');
    var raf = require('raf');
    
    function scroll() {
      var y = window.pageYOffset || document.documentElement.scrollTop;
      var x = window.pageXOffset || document.documentElement.scrollLeft;
      return { top: y, left: x };
    }
    
    function scrollTo(x, y, options) {
      options = options || {};
    
      // start position
      var start = scroll();
    
      // setup tween
      var tween = Tween(start)
        .ease(options.ease || 'out-circ')
        .to({ top: y, left: x })
        .duration(options.duration || 1000);
    
      // scroll
      tween.update(function(o){
        window.scrollTo(o.left | 0, o.top | 0);
      });
    
      // handle end
      tween.on('end', function(){
        animate = function(){};
      });
    
      // animate
      function animate() {
        raf(animate);
        tween.update();
      }
    
      animate();
    
      return tween;
    }
    
    module.exports = scrollTo;
    
    },{"./tween":39,"raf":34}],39:[function(require,module,exports){
    var ease = require('./ease');
    var Emitter = require('./emitter');
    
    function extend(obj, src) {
      for (var key in src) {
        if (src.hasOwnProperty(key)) obj[key] = src[key];
      }
      return obj;
    }
    
    function Tween(obj) {
      if (!(this instanceof Tween)) return new Tween(obj);
      this._from = obj;
      this.ease('linear');
      this.duration(500);
    }
    
    Emitter(Tween.prototype);
    
    Tween.prototype.reset = function(){
      this.isArray = Object.prototype.toString.call(this._from) === '[object Array]';
      this._curr = extend({}, this._from);
      this._done = false;
      this._start = Date.now();
      return this;
    };
    
    Tween.prototype.to = function(obj){
      this.reset();
      this._to = obj;
      return this;
    };
    
    Tween.prototype.duration = function(ms){
      this._duration = ms;
      return this;
    };
    
    Tween.prototype.ease = function(fn){
      fn = 'function' == typeof fn ? fn : ease[fn];
      if (!fn) throw new TypeError('invalid easing function');
      this._ease = fn;
      return this;
    };
    
    Tween.prototype.stop = function(){
      this.stopped = true;
      this._done = true;
      this.emit('stop');
      this.emit('end');
      return this;
    };
    
    Tween.prototype.step = function(){
      if (this._done) return;
    
      var duration = this._duration;
      var now = Date.now();
      var delta = now - this._start;
      var done = delta >= duration;
    
      if (done) {
        this._from = this._to;
        this._update(this._to);
        this._done = true;
        this.emit('end');
        return this;
      }
    
      var from = this._from;
      var to = this._to;
      var curr = this._curr;
      var fn = this._ease;
      var p = (now - this._start) / duration;
      var n = fn(p);
    
      if (this.isArray) {
        for (var i = 0; i < from.length; ++i) {
          curr[i] = from[i] + (to[i] - from[i]) * n;
        }
    
        this._update(curr);
        return this;
      }
    
      for (var k in from) {
        curr[k] = from[k] + (to[k] - from[k]) * n;
      }
    
      this._update(curr);
      return this;
    };
    
    Tween.prototype.update = function(fn){
      if (0 == arguments.length) return this.step();
      this._update = fn;
      return this;
    };
    
    module.exports = Tween;
    
    },{"./ease":35,"./emitter":36}]},{},[28]);
    